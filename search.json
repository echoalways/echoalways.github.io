[{"title":"读《琅嬛文集》录","url":"/2020/05/12/2020-05-12-%E8%AF%BB%E3%80%8A%E7%90%85%E5%AC%9B%E6%96%87%E9%9B%86%E3%80%8B%E5%BD%95/","content":"近来读张岱《琅嬛文集》，遇见许多赏心悦目的文字，摘录此篇分享给大家。\n\n\n\n\n故知世间山川、云物、水火、草木、色声、香味，莫不有冰雪之气；其所以恣人挹取受用之不尽者，莫深于诗文。\n山之有空翠，气之有沆瀣，月之有烟霜，竹之有苍蒨，食味之有生鲜，古铜之有青绿，玉石之有胞浆，诗之有冰雪，皆是物也。苏长公曰：“子由近作《栖贤僧堂记》，读之惨凉，觉崩崖飞瀑，逼人寒栗。”噫！此岂可与俗人道哉！笔墨之中，崖瀑何从来哉！\n​                                            ——一卷冰雪文序\n余幼遵大父教，不读朱注。凡看经书，未尝敢以各家注疏横据胸中。正襟危坐，朗诵白文数十余过，其意义忽然有省。间有不能强解者，无意无义，贮之胸中。或一年，或二年，或读他书，或听人议论，或见山川云物鸟兽虫鱼，触目惊心，忽于此书有悟，取而出之，名曰《四书遇》。盖“遇”之云者，谓不于其家，不于其寓，直于途次之中邂逅遇之也。古人见道旁蛇斗而悟草书，见公孙大娘舞剑器而笔法大进，盖真有以遇之也。古人精思静悟，钻研已久，而石火电光，忽然灼露，其机神摄合，政不知从何处着想也。举子十年攻苦于风檐寸晷之中，构成七艺，而主司以醉梦之余，忽然相投，如磁引铁，如珀摄刍，相悦以解。直欲以全副精神注之，其所遇之奥窍，真有不可得而自解者矣。推而究之，色声香味触发中间无不有遇之一窍，特留以待深心明眼之人，邂逅相遇，遂成莫逆耳。\n余遭乱离两载，东奔西走，身无长物，委弃无余。独于此书，收之箧底，不遗只字。\n​                                               ——四书遇序\n鸡鸣枕上，夜气方回，因想余生平：繁华靡丽，过眼皆空，五十年来，总成一梦。今当黍熟黄粱，车旋蚁穴，当作如何消受？遥思往事，忆即书之，持向佛前，一一忏悔。不次岁月，异年谱也；不分门类，别志林也。偶拈一则，如游旧径，如见故人，城郭人民，翻用自喜，真所谓痴人前不得说梦矣。\n昔有西陵脚夫，为人担酒，失足破其瓮，念无以偿，痴坐伫想曰：“得是梦便好。”一寒士乡试中式，方赴鹿鸣宴，恍然犹忆非真，自啮其臂曰：“莫是梦否？”一梦耳，惟恐其非梦，又惟恐其是梦，其为痴人则一也。余今大梦将寤，犹事雕虫，又是一番梦呓。因叹慧业文人，名心难化，政如邯郸梦断，漏尽钟鸣，卢生遗表，犹思摹拓二王，以流传后世。则其名根一点，坚固如佛家舍利，劫火猛烈，犹烧之不失也。\n​                                             ——陶庵梦忆序\n周又新先生每啜茶，辄道白门闵文水。尝曰：“恨不令宗子见。”一日，文水至越，访又新先生，携茶具，急至予舍。余时在武陵不值，后归，甚懊丧。\n戊寅余至白门。甫登岸，即往桃叶渡访文水。时日晡矣，余至文水家，文水亦他出。余坐久。余意文水一少年好事者，及至，则瞿瞿一老子，与余叙款曲，愕愕如野鹿不可接。方欲纵谈，而老子忽起曰：“余杖忘某所，去取杖。”起席竟去。余曰：“今日岂可空去？”待其返，更定矣。老子睨余曰：“客尚在耶？客尚在何为者？”余曰：“周又老尝道闵先生精饮事，愿借余沥以解渴思。”文水喜，即自起当炉，茶旋煮，速如风雨。导至一室，幽窗净几，荆溪壶及成宣窑瓷瓯十余具，皆精绝。余问老子曰：“此茶何产？”老子曰：“阆苑茶也。”余再啜之，曰：“莫绐余，是阆苑制法而味不似。”老子昵笑曰：“客知是何产？”余再啜之，曰：“何其似罗嵑甚也？”老子吐舌曰：“奇！奇！”余问水曰：“何水？”老子曰：“惠水。”余又曰：“莫绐余，惠水至此千里，岂有水之圭角毫芒不动，生磊若是乎？”老子曰：“不复敢隐。舍间取水，必俟惠山人静夜分涸其井，淘洗数次，至黎明，涓流初满，载以大瓮，藉以文石。舟非风则勿行，水体不劳，水性不熟，故与他泉特异。”又吐舌曰：“奇奇！”言未毕，老子自去。少顷，一壶满斟余曰：“客啜此。”余曰：“香扑烈甚，味浑厚，此春茶也，向瀹者的是秋采。”老子大笑曰：“余年七十，精饮事五十余年，未尝见客之赏鉴若此之精也。五十年知己，无出客右，岂周又老谆谆向余道山阴有张宗老者，得非客乎？”余又大笑。遂相好如生平欢，饮啜无虚日。\n​                                                ——茶史序\n盖闻地有高人，品格与山川并重；亭遗古迹，梅花偕姓氏俱香。名流虽已代迁，胜事自须人补。在孤山逸老，高洁韵同秋水，孤清操比寒梅。疏影横斜，远映西湖清浅；暗香浮动，长陪夜月黄昏。今乃人去山空，依然水流花放。瑶葩洒雪，乱点冢上苔痕；玉树迷烟，恍堕林间鹤羽。兹来韵友，欲步先贤，补种千梅，重开孤屿。凌寒三友，蚤结九里松篁；破腊一枝，远谢六桥桃柳。[插图]想水边半树，点缀冰花；待披雪后横枝，低昂铁干。美人来自林下，高士卧于山中。白石苍厓，拟筑草亭招素鹤；浓山淡水，闲锄明月种梅花。有志竟成，无约不践。将与罗浮争艳，还期庾岭分香。实为林处士之功臣，亦是苏东坡之胜友。吾辈常劳梦想，应有宿缘。哦《曲江诗》，便见孤芳风韵；读《广平赋》，尚思铁石心肠。共策灞水之驴，且向段桥踏雪；遥期漆园之蝶，群来林墓寻梅。莫负佳期，用追芳躅。\n​                                          ——补孤山种梅序\n昔有一僧人与一士子同宿夜航船，士子高谈阔论，僧畏慑，卷足而寝。僧听其语有破绽，乃曰：“请问相公，澹台灭明是一个人，是两个人？”士子曰：“是两个人。”僧曰：“这等，尧舜是一个人两个人？”士子曰：“自然是一个人。”僧人乃笑曰：“这等说起来，且待小僧伸伸脚。\n​                                             ——夜航船序\n余生不辰，阔别西湖二十八载。然西湖无日不入吾梦中，而梦中之西湖实未尝一日别余也。前甲午、丁酉，两至西湖，如涌金门、商氏之楼外楼、祁氏之偶居、钱氏余氏之别墅，及余家之寄园一带湖庄，仅存瓦砾。则是余梦中所有者，反为西湖所无。及至断桥一望，凡昔日之歌楼舞榭，弱柳夭桃，如洪水渰没，百不存一矣。余乃急急走避，谓余为西湖而来，今所见若此，反不若保吾梦中之西湖为得计也。因想余梦与李供奉异，供奉之梦天姥也，如神女名姝，梦所未见，其梦也幻。余之梦西湖也，如家园眷属，梦所故有，其梦也真。\n今余僦居他氏，已二十二载，梦中犹在故居。旧役小傒，今已白头，梦中仍是总角。夙习未除，故态难脱。而今而后，余但向蝶庵岑寂，蘧榻纡徐，惟吾旧梦是保，一派西湖景色，犹端然未动也。儿曹诘问，偶为言之，总是梦中说梦，非魇即呓也。余犹山中人归自海上，盛称海错之美，乡人竞来共舐其眼。嗟嗟，金齑瑶柱，过舌即空，则舐眼亦何救其馋哉？第作《梦寻》七十二则，留之后世，以作西湖之影。\n​                                             ——西湖梦寻序\n幸生胜地，鞋靸间饶有山川，喜作闲人，酒席间只谈风月。野航恰受，不逾两三；便榼随行，各携一二。僧上凫下，觞止茗生。谈笑杂以诙谐，陶写赖此丝竹。兴来即出，可趁樵风：日暮辄归，不因剡雪。愿邀同志，用续前游。\n​                                            ——游山小启\n会稽佳山水，甲于天下，而霞蔚云蒸，尤聚于山阴道上。故随足所至，皆胜地名山。王右军卜居兹土，于千岩万壑中，独取兰亭一席地。其景物风华，定当妙绝千古。且余少时见兰亭墨刻，岩峦奇峭，亭榭巍峨，曲水流觞，浴鹅涤砚。开卷视之，不禁神往。\n​                                             ——古兰亭辩 \n蜀人张岱，陶庵其号也。少为纨绔子弟，极爱繁华，好精舍，好美婢，好娈童，好鲜衣，好美食，好骏马，好华灯，好烟火，好梨园，好鼓吹，好古董，好花鸟，兼以茶淫橘虐，书蠹诗魔。劳碌半生，皆成梦幻。年至五十，国破家亡，避迹山居，所存者破床碎几，折鼎病琴，与残书数帙，缺砚一方而已。布衣蔬食，常至断炊。回首二十年前，真如隔世。\n初字宗子，人称石公，即字石公。好著书，其所成者有《石匮书》《张氏家谱》《义烈传》《琅嬛文集》《明易》《大易用》《史阙》《四书遇》《梦忆》《说铃》《昌谷解》《快园道古》《傒囊十集》《西湖梦寻》《一卷冰雪文》行世。\n生于万历丁酉八月二十五日卯时，鲁国相大涤翁之树子也。母曰陶宜人。幼多痰疾，养于外大母马太夫人者十年。外太祖云谷公宦两广，藏生牛黄丸盈数簏，自余囡地以至十有六岁，食尽之而厥疾始瘳。六岁时，大父雨若翁携余之武林，遇眉公先生跨一角鹿，为钱唐游客，对大父曰：“闻文孙善属对，吾面试之”，指屏上李白骑鲸图曰：“太白骑鲸，采石江边捞夜月。”余应曰：“眉公跨鹿，钱唐县里打秋风。”眉公大笑起跃曰：“那得灵隽若此，吾小友也。”欲进余以千秋之业，岂料余之一事无成也哉？\n甲申以后，悠悠忽忽，既不能觅死，又不能聊生，白发婆娑，犹视息人世。恐一旦溘先朝露，与草木同腐，因思古人如王无功、陶靖节、徐文长皆自作墓铭，余亦效颦为之。甫构思，觉人与文俱不佳，辍笔者再。虽然，第言吾之癖错，则亦可传也已。曾营生圹于项王里之鸡头山，友人李研斋题其圹曰：“呜呼，有明著述鸿儒陶庵张长公之圹。”伯鸾高士，冢近要离，余故有取于项里也。明年，年跻七十，死与葬，其日月尚不知也，故不书。\n铭曰：穷石崇，斗金谷。盲卞和，献荆玉。老廉颇，战涿鹿。赝龙门，开史局。馋东坡，饿孤竹。五羖大夫，焉肯自鬻。空学陶潜，枉希梅福。必也寻三外野人，方晓我之衷曲。\n​                                            ——自为墓志铭\n昔日东坡思栗里，良穗怀新，写尽澄心纸。今见平畴如绿绮，翻来白浪潮头起。野老豚蹄心更侈，篝满瓯窭，奢愿还无已。处处军输如吸髓，敢云畎亩忘庚癸。\n​                                               ——平畴麦浪\n何必微萤量数斛，遇夜嬉游，囊火燃山谷。怎比渔灯千万簇，星星炤出田畴绿。疑是天河成反覆，遍野疏星，连住招摇宿。此际神槎乘博陆，支机石冷空杼柚。\n​                                              ——孤村渔火\n雪巘晴光如缺列，闪烁凝晴，入眼翻成瞥。一幅鹅绫无缁涅，条条水道如轨辙。山入秋湖皆小垤，滋蔓难图，迢递如瓜瓞。余到洛伽心胆裂，银狮蹴起潮头雪。\n​                                              ——三山霁雪\n","categories":["诗歌手记"]},{"title":"木心诗二三句","url":"/2020/06/12/2020-06-12-%E6%9C%A8%E5%BF%83%E8%AF%97%E4%BA%8C%E4%B8%89%E5%8F%A5/","content":"木心的诗，感觉语言上特别有古意与情味，其诗描写故景往事者读之令人口齿含香，即刻诵之。今日夏初梅雨，摘之二三，与时消夏。\n\n\n\n\n少年朝食\n    清早阳光\n    照明高墙一角\n    喜鹊喀喀叫\n    天井花坛葱茏\n    丫鬟悄声报用膳\n    紫檀圆桌\n    四碟端陈\n    姑苏酱鸭\n    平湖糟蛋\n    撕蒸笋\n    豆干末子拌马兰头\n    莹白的暖暖香粳米粥\n    没有比粥更温柔的了\n    东坡、剑南皆嗜粥\n    念予毕生流离红尘\n    就找不到一个似粥温柔之人\n    吁，予仍频忆江南古镇\n    梁昭明太子读书于我家后园\n    窗前的银杏树是六朝之前的\n    昔南塘春半、风和马嘶\n    日长无事蝴蝶飞\n\n\n\n大卫\n莫倚偎我\n我习于冷\n志于成冰\n莫倚偎我\n别走近我\n我正升焰\n万木俱焚\n别走近我\n\n\n\n\n\n\n清嘉录\n**其一**\n\n平明舟出山庄\n万枝垂柳，烟雨迷茫\n回眺岸上土屋亦如化境\n舟子挽纤行急\n误窜层网中，遂致勃谿\n登岸相劝，几为乡人窘\n偿以百钱，始悻悻散\n    \n行百余里，滩险日暮\n约去港口数里以泊\n江潮大来，荻芦如雪\n肃肃与风相抟\n是夕正望，月似紫铜盘\n水势益长，澎湃声起\n俄闻金山蒲牢动，漏下矣\n    \n**其二**\n\n梅雨时备缸瓮收旧雨水\n供烹茶，曰梅水\n梅天多雨，雨水极佳\n贮之味经年不变\n人于初交黄梅时收雨\n以其甘滑胜山泉\n\n\n​    \n从前慢\n记得早先少年时\n大家诚诚恳恳\n说一句是一句\n清早上火车站\n长街黑暗无行人\n卖豆浆的小店冒着热气\n    \n从前的日色变得慢\n车、马、邮件都慢\n一生只够爱一个人\n    \n从前的锁也好看\n钥匙精美有样子\n你锁了，人家就懂了\n\n\n\n\n\n魏玛早春\n有一株树\n曾见一株这样的树\n冬季晴和了几天\n不觉彤云叆叇\n万千乌鸦出林\n聒鸣飞旋\n乡民谓之噪雪\n称彤云为酿雪\n风凛冽\n行人匆匆回家\n曾见一株树在这样的时日\n枝头齐茁蓓蕾\n淡绛的星星点点密布楂条\n长势迅速梢端尤累累若不胜载\n际此霙雪纷纷下\n无数花苞仰雪绽放\n雪片愈大愈紧\n群花朵朵舒展\n树高十米\n干围一点五米\n叶如樟似杨\n顶冠直径十余米\n花状类乎扶桑之樱\n色与雪同\n吐香清馥\n冬季中下几遭雪\n发几度花\n霰霙之夕\n寂然不应\n初雪之顷无气息\n四野积雪丰厚\n便闲幽馨流播\n昼夜氤氲\n雪销\n花凋谢\n植物志上没有这株树的学名\n中国洞庭湖之南湘省 洞口县 水口山\n树在那里已两百多年\n\n\n\n\n爪哇国\n从前的人真有趣\n他们要形容荒唐\n便说“一错错到了爪哇国”\n他们以为爪哇是最远的了\n你想明朝人有多可爱\n\n\n\n\n\n如偈\n晚晴风光好\n大梦觉犹眠\n每忆儿时景\n莲叶何田田\n\n\n\n\n\n谑庵片简\n隆恩寺无他奇\n独大会明堂百余丈\n可玩月\n径下有云深庵\n五月，啖其樱桃\n八月，落其苹果\n樱桃人啖后百鸟俱来\n绿羽翠翎者，白身朱咮者\n嘈嘈各呈妙音\n\n\n\n\n\n京师五月\n石榴花正开\n照眼鲜明\n居人每与夹竹桃列中庭\n榴竹之间，配以鱼缸\n朱鳞数尾游漾其中\n几于家家如此\n\n\n\n\n\n我\n我是一个在黑暗中大雪纷飞的人哪\n\n\n\n\n\n浣花溪归\n出成都门\n左万里桥\n西折，溪流纤秀长曲\n如连环，如玦色\n如鉴，如琅玕\n窈然深碧\n潆回城下\n皆浣花溪之委也\n\n\n\n\n\n夏日山居\n遍地悬铃木\n树叶杂花横生\n紫檀，木兰，石榴\n扇形的棕榈\n油润润的乌柏\n\n朝暾初升\n小丘上阳光已很强烈\n芬芳的雾闪着兰晕\n林薮蓊郁，群峦后\n终年积雪的巍巍高峰\n","categories":["诗歌手记"]},{"title":"恭王府花园游记","url":"/2020/11/12/2020-11-12-%E6%81%AD%E7%8E%8B%E5%BA%9C%E8%8A%B1%E5%9B%AD%E6%B8%B8%E8%AE%B0/","content":"\n\n\n阳光很好的周六下午，去了恭王府，相比故宫一片金碧辉煌井然有序的宫殿建筑群，颐和园一片水边山边的园林图景，我更喜欢这一处人家院落里营造的园林风景，一如我一直喜爱的苏州园林！真的很喜欢恭王府的后花园了！以后要和喜欢的朋友一起去，在春天花开的时候，在夏天绿树浓荫的时候……希望会有吧。\n在西二旗地铁站的时候，也许是周末，北京的地铁站永远不缺熙攘的人群，在一辆地铁驶来后，站台人流散去，呈现一片寂寥之感，我的眼前飘来一朵蒲公英，我开心的走向前用手接起，白色的绒球下面是一粒黑色羽片状的种子，想象它是冬奥会场飘出来的一朵，忽然很开心，把它小心翼翼的揣兜里。\n是在北海北下的，出站便能看见文物研究所，往三座桥胡同北走，便到了恭王府的所在，藏在胡同里的恭王府是寂静的，从正门进去，会穿过很多垂花门和庭院，院子里种满松柏，两侧亦有屋舍，设了一些展览，是高山流水漆器展和山西忻州剪纸作品展览。\n后院是一个很大的花园，杂以山石草木，屋舍绮花，是我喜欢的所在了！\n园子里堆了许多假山，便有了高低错落之感，人行其中，攀石寻径，若隐若现。假山上砌了亭子，坐在亭子上可一览周遭景致，遇友人来，对弈于此，秋爽高风，岂不快乐！另有一处假山，两边是山径游廊，顺游廊而上，可到一高处，名“邀月亭”，若逢日落西山，新月初霁，可揽月于此，我歌月徘徊，我舞影零乱。\n园子西侧有一处水池，池中有湖心亭，湖畔有是一面有实墙的走廊，走廊穿以漏景窗，可坐倚栏杆上，看绿波游鱼。邀月亭假山后面，又有一处山房，名蝠厅，柱子上画成了竹子的形状，门窗尽绿，和旁边簇拥的竹子相映成趣，很有红楼梦里潇湘馆的感觉！我恍惚看见书中的“黛玉”正倚在廊边。\n东面是梧桐院和听雨轩，先说梧桐院，果真是一处隐藏起来的院子，因为被假山掩遮，闲静时可偃卧此间。听雨轩，适合一个人的时候，逢着雨落，听着屋外雨打蕉叶三两声，细细的让人落入空茫……\n听雨轩过去是一处圆拱门，种满了竹子，有种曲径通幽的感觉，另有一处所在，名“怡神所”，四面屋绕，中间植以绿竹，一走进便有遮天蔽日的浓荫，适合夏日消暑，清寂之极，稍有一点风便能听见竹叶沙沙作响，果然闻之叫人心旷神怡！园中诸多景致，想见四时各异，待日后一一赏玩。\n回前门经过佛楼，佛楼前有一排转经筒，来往的游人把它拨动。我知道西藏那边是有的，藏人对神山圣水的拜谒使我敬重。我也去拨动那转经筒，希望等到属于我的好运！\n\n\n]\n]\n\n]\n]\n]\n]\n\n","categories":["山水行"]},{"title":"MyBatis-Plus整合笔记","url":"/2023/10/04/MyBatis-Plus%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/","content":"\n\nSpring Boot集成MyBatis-Plus持久层框架实现数据库连接，支持自定义增删改查、条件构造器、分页插件、代码生成。\n\n\n简介 | MyBatis-Plus (baomidou.com)\n1、快速整合MyBatis-Plus第一步，在 pom.xml 中引入 starter。 \n&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;\n\n第二步，使用 @MapperScan 注解扫描 mapper 文件。\n@Configuration@ComponentScan(&quot;com.github.paicoding.forum.service&quot;)@MapperScan(basePackages = &#123; &quot;com.github.paicoding.forum.service.article.repository.mapper&quot;, &quot;com.github.paicoding.forum.service.user.repository.mapper&quot;, &quot;com.github.paicoding.forum.service.comment.repository.mapper&quot;, &quot;com.github.paicoding.forum.service.config.repository.mapper&quot;, &quot;com.github.paicoding.forum.service.statistics.repository.mappe &quot;com.github.paicoding.forum.service.notify.repository.mapper&quot;,&#125;public class ServiceAutoConfig &#123;&#125;\n\nServiceAutoConfig 是单独的配置类，mapper 接口按照业务进行了分类，mapper.xml  放在 resources 目录下。\n第三步，在 application.yml 文件中增加MyBatis-Plus 的统一配置。\n# mybatis 相关统一配置mybatis-plus: configuration: #开启下划线转驼峰 map-underscore-to-camel-case: true\n\n将数据库表中的下划线命名方式 （underscore case）映射为 Java 对象中的驼峰命名方式（camel case）。例如，数据库 表中的列名为 user_name，对应的 Java 对象的属性名为 userName。\n2、MyBatis-Plus的基本使用2.1、Service CRUD示例：比如说我们要保存一个文章的标签。\n@Autowiredprivate TagDao tagDao;tagDao.save(tagDO);\n\ntagDao 是我们定义的数据访问对象（Data Access Object，简称 DAO），它继承自  MyBatis-Plus 提供的 ServiceImpl 类。 @Autowired 注解将 TagDao 自动注入到当前类 中。这是 Spring 提供的依赖注入（DI）功能，可以让我们在当前类中方便地使用  TagDao。\n@Repositorypublic class TagDao extends ServiceImpl&lt;TagMapper, TagDO&gt; &#123;&#125;\n\n\n @Repository 注解：这是 Spring 提供的注解，用于标识这个类是一个数据访问层 （DAO）组件。Spring 会自动扫描并将其实例化为一个 Bean，方便在其他类中通过依赖 注入（DI）使用。\n\n\nServiceImpl 是 MyBatis-Plus 提供的一个抽象类，提供了通用的 CRUD 方法。泛型参数  意味着 TagDao 类 主要用于处理 TagDO 数据对象的数据库操作，并使用 TagMapper 接口定义的方法进行操作。\n\n通过继承 ServiceImpl 类，TagDao 就可以使用 MyBatis-Plus 提供的通用 CRUD 方法，如 save、getById、updateById 等。这些方法已经实现了基本的数据库操作，通常无需自 己编写 SQL 语句。\n参数 tagDO 是一个数据对象（Data Object，简称 DO），表示数据库中的 tag 表。\n@Data@EqualsAndHashCode(callSuper = true)@TableName(&quot;tag&quot;)public class TagDO extends BaseDO &#123; private static final long serialVersionUID = 3796460143933607644L; /** * 标签名称 */ private String tagName; /** * 标签类型：1-系统标签，2-自定义标签 */ private Integer tagType; /** * 状态：0-未发布，1-已发布 */ private Integer status; /** * 是否删除 */ private Integer deleted;&#125;\n\n\n @Data 注解是 Lombok 提供的，用于自动生成类的 getter、setter、equals、 hashCode 和 toString 方法，简化了代码编写。 \n@EqualsAndHashCode(callSuper &#x3D; true) 注解也是 Lombok 提供的注解， cal lSuper &#x3D; true 表示要调用父类（BaseDO）的 equals 和 hashCode 方法。\n\nBaseDO 是我们自定义的 DO 基类，实现了 Serializable 接口 ，并且定义了主键 id（ @TableI d(type &#x3D; IdType.AUTO) 表示自增长，是 MyBatis-Plus 提供的注解），创建时间  createTime和更新时间 updateTime。\n@Datapublic class BaseDO implements Serializable &#123; @TableId(type = IdType.AUTO) private Long id; private Date createTime; private Date updateTime;&#125;\n\n\n\n @TableName(“tag”) 注解是 MyBatis-Plus 提供的注解，用于指定数据库表名。 \n另外定义了四个属性：tagName（标签名称）、tagType（标签类型）、status（状 态）和 deleted（是否删除）。这些属性对应数据库表中的列。\n2.2、Mapper CRUDMyBatis-Plus 除了提供 Service 的 CRUD， 还提供了基于 Mapper 的 CRUD。 通常一些特殊的增删改查是通过 MyBatis-Plus 的 Mapper CRUD 接口实现的。 \n示例：比如说我们要保存文章，可以通过下面这种方式。\n@Repositorypublic class ArticleDao extends ServiceImpl&lt;ArticleMapper, ArticleDO&gt; &#123; @Resource private ArticleDetailMapper articleDetailMapper;  public Long saveArticleContent(Long articleId, String content) &#123; ArticleDetailDO detail = new ArticleDetailDO(); detail.setArticleId(articleId); detail.setContent(content); detail.setVersion(1L); articleDetailMapper.insert(detail); return detail.getId(); &#125;&#125;\n\n\n\narticleDetailMapper 是我们在当前类中注入的一个 Mapper 接口，它继承自 MyBatis-Plus 的 BaseMapper 接口。\npublic interface ArticleDetailMapper extends BaseMapper&lt;ArticleDetailDO&gt;&#123;&#125;\n\n\n\n/** * Mapper 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能 * &lt;p&gt;这个 Mapper 支持 id 泛型&lt;/p&gt; * * @author hubin * @since 2016-01-23 */public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt; &#123; /** * 插入一条记录 * * @param entity 实体对象 */ int insert(T entity);  /** * 根据 entity 条件，删除记录 * * @param queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用 */ int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);  /** * 根据 whereEntity 条件，更新记录 * * @param entity 实体对象 (set 条件值,可以为 null) * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity  */ int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAP  /** * 根据 ID 查询 * * @param id 主键ID */ T selectById(Serializable id);&#125;\n\n这样，articleDetailMapper 也就具备了基本的增删改查功能。\n2.3、常用注解\n\n\n\n\n\n\n\n@TableName\n用于指定数据库表名，通常在实体类（DO 或 Entity）上使用。例如： @TableName(“user”) 。\n\n\n@TableId\n用于指定表中的主键字段。通常在实体类的主键属性上使用。例如： @ TableId(value &#x3D; “id”, type &#x3D; IdType.AUTO) ，其中 value 表示主键字段名， type 表示主键生成策略。\n\n\n@TableField\n用于指定表中的非主键字段。可以用于实体类的属性上，以映射属 性和数据库字段。\n\n\n@TableLogic\n用于指定逻辑删除字段。逻辑删除是指在数据库中标记某个记录已 删除，而不是真正地删除记录。例如： @TableLogic(value &#x3D; “0”, delval &#x3D;  “1”) ，其中 value 表示未删除状态的默认值，delval 表示删除状态的值。\n\n\n@Version\n用于指定乐观锁字段。乐观锁是一种并发控制策略，用于解决多个线程 同时修改同一条记录的问题。例如： @Version private Integer version;\n\n\n3、MyBatis-Plus查询3.1、普通查询MyBatis-Plus 的 BaseMapper 提供了多种查询方法，比如说根据 ID 查找文章是这样用的：\nArticleDO article = baseMapper.selectById(articleId);\n\n除此之外，还有根据ID 批量查询的 selectBatchIds：\nbaseMapper.selectBatchIds(Arrays.asList(1,2));\n\n根据键值对查询的 selectByMap：\nMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;id&quot;, 15L);List&lt;ArticleDO&gt; dtoList = baseMapper.selectByMap(map);\n\n\n\n3.2、条件构造器MyBatis-Plus 的 Wrapper 是一个条件构造器，用于简化复杂的 SQL 查询条件的构建。它 提供了一系列易于使用的 API，让你能够以链式编程的方式编写查询条件，而不需要手动编 写 SQL 语句。\n示例：假如我们来查询这样一个结果，包含“j”且状态是已发布的标签。我们可以这样来构建条件构造器。\n@Testpublic void testWrapper() &#123; QueryWrapper&lt;TagDO&gt; wrapper = new QueryWrapper&lt;&gt;(); // 包含“j”且状态是已发布 wrapper.like(&quot;tag_name&quot;, &quot;j&quot;).eq(&quot;status&quot;, 1); BaseMapper&lt;TagDO&gt; baseMapper = tagDao.getBaseMapper(); List&lt;TagDO&gt; tagList = baseMapper.selectList(wrapper); tagList.forEach(System.out::println);&#125;\n\n\n\nQueryWrapper：用于构建查询条件。它继承自 AbstractWrapper，提供了各种查询条件 的构建方法，如 eq, ne, gt, ge, lt, le, like, isNull, orderBy 等等。详细见：条件构造器 | MyBatis-Plus (baomidou.com)\n但是，通过表的字段总感觉很不舒服，万一哪一天数据库表发生变化了怎么办呢？代码和数据库就不匹配了呀。 更优雅的做法是采用 Lambda 的方式，如下查询标签示例：\npublic List&lt;TagDTO&gt; listOnlineTag(String key, PageParam pageParam) &#123; LambdaQueryWrapper&lt;TagDO&gt; query = Wrappers.lambdaQuery(); query.eq(TagDO::getStatus, PushStatusEnum.ONLINE.getCode()) .eq(TagDO::getDeleted, YesOrNoEnum.NO.getCode()) .and(!StringUtils.isEmpty(key), v -&gt; v.like(TagDO::getTagNa .orderByDesc(TagDO::getId); if (pageParam != null) &#123; query.last(PageParam.getLimitSql(pageParam)); &#125; List&lt;TagDO&gt; list = baseMapper.selectList(query); return ArticleConverter.toDtoList(list);&#125;\n\n①、可以通过 Wrappers.lambdaQuery() 静态方法创建一个 Lambda 条件构造器。 \n②、 eq(TagDO::getStatus, PushStatusEnum.ONLINE.getCode()) ：表示查询条件 为 status 等于 PushStatusEnum.ONLINE 的值（即查询上线的标签）。 \n③、 eq(TagDO::getDeleted, YesOrNoEnum.NO.getCode()) ：表示查询条件为  deleted 等于 YesOrNoEnum.NO 的值（即查询未删除的记录）。 \n④、 and(!StringUtils.isEmpty(key), v -&gt; v.like(TagDO::getTagName, ke y)) ：表示如果 key 不为空，则添加一个查询条件，要求 tag_name 包含 key。 \n⑤、 orderByDesc(TagDO::getId) ：表示按照 id 字段降序排序。\n⑥、 if (pageParam !&#x3D; null) { query.last(PageParam.getLimitSql(pagePara  m)); } ：如果 pageParam 不为 null，则添加分页参数。\n这样的话，就可以和数据库的字段隔离开，完全通过代码的方式去查询。\n3.3、MyBatis-Plus自定义SQLMyBatis-Plus 支持自定义 SQL 语句，我们可以在 Mapper 接口中编写自定义 SQL 方法， 并使用注解添加自定义的 SQL 语句。 \n示例：微信登录的时候会执行这条 SQL 语句。\npublic interface UserMapper extends BaseMapper&lt;UserDO&gt; &#123; /** * 根据三方唯一id进行查询 * * @param accountId * @return */ @Select(&quot;select * from user where third_account_id = #&#123;account_id&#125;  UserDO getByThirdAccountId(@Param(&quot;account_id&quot;) String accountId);&#125;\n\n接口中定义了一个名为 getByThirdAccountId 的方法，它接收一个名为 accountId 的参 数。 \n该方法使用了 @Select 注解，这个注解用于编写自定义的 SQL 查询。 @Select 注解内的 SQL 语句是： select * from user where third_account_id = #&#123;account_i d&#125; limit 1 ，它会根据传入的 account_id 参数查询 user 表中的记录。 同时，方法参数 accountId 使用了 @Param 注解，指定了参数在 SQL 语句中的名称为  account_id。这样，在执行 SQL 语句时，MyBatis 会将参数值替换到对应的位置上。\n除此之外，可以使用 xml 的方式，用来定义一些复杂的 SQL。\n比如说，我们要统计网站的 PV、UV，那么我们在 resources 目录下新建一个名为  QueryCountMapper.xml 的文件，内容如下：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://my&lt;mapper namespace=&quot;com.github.paicoding.forum.service.statistics.reposi &lt;select id=&quot;getPvTotalCount&quot; resultType=&quot;java.lang.Long&quot;&gt; select sum(cnt) from request_count &lt;/select&gt; &lt;select id=&quot;getPvDayList&quot; resultType=&quot;com.github.paicoding.forum.ap SELECT sum(cnt) as count, date FROM request_count group by date order by date asc limit #&#123;day&#125;; &lt;/select&gt; &lt;select id=&quot;getUvDayList&quot; resultType=&quot;com.github.paicoding.forum.ap SELECT count(*) as count, date FROM request_count group by date order by date asc limit #&#123;day&#125;; &lt;/select&gt;&lt;/mapper&gt;\n\n①、在 resources 目录下的好处是，MyBatis-Plus 默认帮我们配置了 xml 的位置，这样我们就不需要在 application.yml 中再配置了。\n②、该 XML 文件定义了一个RequestCountMapper 映射器，它包含三个自定义查询：getPvTotalCount、getPvDayList 和 getUvDayList。与com.github.paicoding.forum.service.statistics.repository.mapper.RequestCountMapper 相匹配。\npublic interface RequestCountMapper extends BaseMapper&lt;RequestCountDO&gt;  /** * 获取 PV 总数 * * @return */ Long getPvTotalCount(); /** * 获取 PV 数据列表 * @param day * @return */ List&lt;StatisticsDayDTO&gt; getPvDayList(@Param(&quot;day&quot;) Integer day); /** * 获取 UV 数据列表 * * @param day * @return */ List&lt;StatisticsDayDTO&gt; getUvDayList(@Param(&quot;day&quot;) Integer day);&#125;\n\n\n\n4、MyBatis-Plus主键策略\n\n\n策略\n含义\n\n\n\nIdType.AUTO\n自增策略，也就是说，在插入数据时，无需设置主键值，数据库会自动分配主键值，数据库表的 ID 会设置为 Auto  Increment。\n\n\nIdType.NONE\n无主键策略。表示不使用任何主键生成策略，主键值需要手动设置。\n\n\nIdType.UUID\n使用 UUID 作为主键。插入数据时，MyBatis-Plus 会自动生成一个 UUID  值作为主键值。\n\n\nIdType.ID_WORKER\n使用雪花算法生成分布式唯一 ID。插入数据时，MyBatis-Plus 会 自动生成一个雪花 ID 作为主键值。\n\n\npublic class User &#123; @TableId(type = IdType.ID_WORKER) //默认 private Long id; // ...&#125;\n\n","categories":["Spring Boot"]},{"title":"Easy-RPC框架实现","url":"/2023/10/04/Easy-RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/","content":"\n\n一款基于 Nacos 实现的 RPC 框架。网络传输实现了基于 Java 原生 Socket 与 Netty 版本，并且实现了多种序列化与负载均衡算法。\n\n\n项目地址：https://gitcode.net/mirrors/cn-guoziyang/my-rpc-framework?utm_source=csdn_github_accelerator\n文档记录：https://blog.csdn.net/qq_40856284/category_10138756.html\nRPC框架图：\n\n1、一个最简单的实现大体思路：\n客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回给客户端，作为客户端调用接口方法的返回值。\n需要考虑的：\n客户端怎么知道服务端的地址？客户端怎么告诉服务端我要调用的接口？客户端怎么传递参数？只有接口客户端怎么生成实现类？\n这一章，我们就来探讨一个最简单的实现。一个最简单的实现，基于这样一个假设，那就是客户端已经知道了服务端的地址，这部分会由后续的服务发现机制完善。\n1.1、通用接口我们先把通用的接口写好，然后再来看怎么实现客户端和服务端。\n接口如下：\npublic interface HelloService &#123;    String hello(HelloObject object);&#125;\n\nhello方法需要传递一个对象，HelloObject对象，定义如下：\n@Data@AllArgsConstructorpublic class HelloObject implements Serializable &#123;    private Integer id;    private String message;&#125;\n\n注意这个对象需要实现Serializable接口，因为它需要在调用过程中从客户端传递给服务端。\n接着我们在服务端对这个接口进行实现，实现的方式也很简单，返回一个字符串就行：\npublic class HelloServiceImpl implements HelloService &#123;    private static final Logger logger = LoggerFactory.getLogger(HelloServiceImpl.class);    @Override    public String hello(HelloObject object) &#123;        logger.info(&quot;接收到：&#123;&#125;&quot;, object.getMessage());        return &quot;这是掉用的返回值，id=&quot; + object.getId();    &#125;&#125;\n\n\n\n1.2、传输方式我们来思考一下，服务端需要哪些信息，才能唯一确定服务端需要调用的接口的方法呢？\n首先，就是接口的名字，和方法的名字，但是由于方法重载的缘故，我们还需要这个方法的所有参数的类型，最后，客户端调用时，还需要传递参数的实际值，那么服务端知道以上四个条件，就可以找到这个方法并且调用了。我们把这四个条件写到一个对象里，到时候传输时传输这个对象就行了。即RpcRequest对象：\n@Data@Builderpublic class RpcRequest implements Serializable &#123;    /**     * 待调用接口名称     */    private String interfaceName;    /**     * 待调用方法名称     */    private String methodName;    /**     * 调用方法的参数     */    private Object[] parameters;    /**     * 调用方法的参数类型     */    private Class&lt;?&gt;[] paramTypes;&#125;\n\n参数类型我是直接使用Class对象，其实用字符串也是可以的。\n那么服务器调用完这个方法后，需要给客户端返回哪些信息呢？如果调用成功的话，显然需要返回值，如果调用失败了，就需要失败的信息，这里封装成一个RpcResponse对象：\n@Datapublic class RpcResponse&lt;T&gt; implements Serializable &#123;    /**     * 响应状态码     */    private Integer statusCode;    /**     * 响应状态补充信息     */    private String message;    /**     * 响应数据     */    private T data;      public static &lt;T&gt; RpcResponse&lt;T&gt; success(T data) &#123;        RpcResponse&lt;T&gt; response = new RpcResponse&lt;&gt;();        response.setStatusCode(ResponseCode.SUCCESS.getCode());        response.setData(data);        return response;    &#125;    public static &lt;T&gt; RpcResponse&lt;T&gt; fail(ResponseCode code) &#123;        RpcResponse&lt;T&gt; response = new RpcResponse&lt;&gt;();        response.setStatusCode(code.getCode());        response.setMessage(code.getMessage());        return response;    &#125;&#125;\n\n这里还多写了两个静态方法，用于快速生成成功与失败的响应对象。其中，statusCode属性可以自行定义，客户端服务端一致即可。\n1.3、客户端的实现——动态代理客户端方面，由于在客户端这一侧我们并没有接口的具体实现类，就没有办法直接生成实例对象。这时，我们可以通过动态代理的方式生成实例，并且调用方法时生成需要的RpcRequest对象并且发送给服务端。\n这里我们采用JDK动态代理，代理类是需要实现InvocationHandler接口的。\npublic class RpcClientProxy implements InvocationHandler &#123;    private String host;    private int port;    public RpcClientProxy(String host, int port) &#123;        this.host = host;        this.port = port;    &#125;    @SuppressWarnings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy(Class&lt;T&gt; clazz) &#123;        return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class&lt;?&gt;[]&#123;clazz&#125;, this);    &#125;&#125;\n\n我们需要传递host和port来指明服务端的位置。并且使用getProxy()方法来生成代理对象。\nInvocationHandler接口需要实现invoke()方法，来指明代理对象的方法被调用时的动作。在这里，我们显然就需要生成一个RpcRequest对象，发送出去，然后返回从服务端接收到的结果即可：\n@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;    RpcRequest rpcRequest = RpcRequest.builder()            .interfaceName(method.getDeclaringClass().getName())            .methodName(method.getName())            .parameters(args)            .paramTypes(method.getParameterTypes())            .build();    RpcClient rpcClient = new RpcClient();    return ((RpcResponse) rpcClient.sendRequest(rpcRequest, host, port)).getData();&#125;\n\n生成RpcRequest很简单，我使用Builder模式来生成这个对象。发送的逻辑我使用了一个RpcClient对象来实现，这个对象的作用，就是将一个对象发过去，并且接受返回的对象。\npublic class RpcClient &#123;    private static final Logger logger = LoggerFactory.getLogger(RpcClient.class);    public Object sendRequest(RpcRequest rpcRequest, String host, int port) &#123;        try (Socket socket = new Socket(host, port)) &#123;            ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());            objectOutputStream.writeObject(rpcRequest);            objectOutputStream.flush();            return objectInputStream.readObject();        &#125; catch (IOException | ClassNotFoundException e) &#123;            logger.error(&quot;调用时有错误发生：&quot;, e);            return null;        &#125;    &#125;&#125;\n\n我的实现很简单，直接使用Java的序列化方式，通过Socket传输。创建一个Socket，获取ObjectOutputStream对象，然后把需要发送的对象传进去即可，接收时获取ObjectInputStream对象，readObject()方法就可以获得一个返回的对象。\n1.4、服务端的实现——反射调用服务端的实现就简单多了，使用一个ServerSocket监听某个端口，循环接收连接请求，如果发来了请求就创建一个线程，在新线程中处理调用。这里创建线程采用线程池：\npublic class RpcServer &#123;    private final ExecutorService threadPool;    private static final Logger logger = LoggerFactory.getLogger(RpcServer.class);    public RpcServer() &#123;        int corePoolSize = 5;        int maximumPoolSize = 50;        long keepAliveTime = 60;        BlockingQueue&lt;Runnable&gt; workingQueue = new ArrayBlockingQueue&lt;&gt;(100);        ThreadFactory threadFactory = Executors.defaultThreadFactory();        threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workingQueue, threadFactory);    &#125;  &#125;\n\n\n\n这里简化了一下，RpcServer暂时只能注册一个接口，即对外提供一个接口的调用服务，添加register方法，在注册完一个服务后立刻开始监听：\npublic void register(Object service, int port) &#123;    try (ServerSocket serverSocket = new ServerSocket(port)) &#123;        logger.info(&quot;服务器正在启动...&quot;);        Socket socket;        while((socket = serverSocket.accept()) != null) &#123;            logger.info(&quot;客户端连接！Ip为：&quot; + socket.getInetAddress());            threadPool.execute(new WorkerThread(socket, service));        &#125;    &#125; catch (IOException e) &#123;        logger.error(&quot;连接时有错误发生：&quot;, e);    &#125;&#125;\n\n这里向工作线程WorkerThread传入了socket和用于服务端实例service。\nWorkerThread实现了Runnable接口，用于接收RpcRequest对象，解析并且调用，生成RpcResponse对象并传输回去。run方法如下：\n@Overridepublic void run() &#123;    try (ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());         ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream())) &#123;        RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();        Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());        Object returnObject = method.invoke(service, rpcRequest.getParameters());        objectOutputStream.writeObject(RpcResponse.success(returnObject));        objectOutputStream.flush();    &#125; catch (IOException | ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;        logger.error(&quot;调用或发送时有错误发生：&quot;, e);    &#125;&#125;\n\n其中，通过class.getMethod方法，传入方法名和方法参数类型即可获得Method对象。如果你上面RpcRequest中使用String数组来存储方法参数类型的话，这里你就需要通过反射生成对应的Class数组了。通过method.invoke方法，传入对象实例和参数，即可调用并且获得返回值。\n1.5、测试服务端侧，我们已经在上面实现了一个HelloService的实现类HelloServiceImpl的实现类了，我们只需要创建一个RpcServer并且把这个实现类注册进去就行了：\npublic class TestServer &#123;    public static void main(String[] args) &#123;        HelloService helloService = new HelloServiceImpl();        RpcServer rpcServer = new RpcServer();        rpcServer.register(helloService, 9000);    &#125;&#125;\n\n服务端开放在9000端口。\n客户端方面，我们需要通过动态代理，生成代理对象，并且调用，动态代理会自动帮我们向服务端发送请求的：\npublic class TestClient &#123;    public static void main(String[] args) &#123;        RpcClientProxy proxy = new RpcClientProxy(&quot;127.0.0.1&quot;, 9000);        HelloService helloService = proxy.getProxy(HelloService.class);        HelloObject object = new HelloObject(12, &quot;This is a message&quot;);        String res = helloService.hello(object);        System.out.println(res);    &#125;&#125;\n\n我们这里生成了一个HelloObject对象作为方法的参数。\n首先启动服务端，再启动客户端，服务端输出：\n服务器正在启动...客户端连接！Ip为：127.0.0.1接收到：This is a message\n\n客户端输出：\n这是调用的返回值，id=12\n\n\n\n2、注册多个服务上一节中，我们使用 JDK 序列化和 Socket 实现了一个最基本的 RPC 框架，服务端测试时是这样的：\npublic class TestServer &#123;    public static void main(String[] args) &#123;        HelloService helloService = new HelloServiceImpl();        RpcServer rpcServer = new RpcServer();        rpcServer.register(helloService, 9000);    &#125;&#125;\n\n在注册完 helloService 后，服务器就自行启动了，也就是说，一个服务器只能注册一个服务，这个设计非常不好（毕竟是简易实现）。这一节，我们就将服务的注册和服务器启动分离，使得服务端可以提供多个服务。\n2.1、服务注册表我们需要一个容器，这个容器很简单，就是保存一些本地服务的信息，并且在获得一个服务名字的时候能够返回这个服务的信息。创建一个 ServiceRegistry 接口：\npackage top.guoziyang.rpc.registry;public interface ServiceRegistry &#123;    &lt;T&gt; void register(T service);    Object getService(String serviceName);&#125;\n\n一目了然，一个register注册服务信息，一个getService获取服务信息。\n我们新建一个默认的注册表类 DefaultServiceRegistry 来实现这个接口，提供服务注册服务，如下：\npublic class DefaultServiceRegistry implements ServiceRegistry &#123;    private static final Logger logger = LoggerFactory.getLogger(DefaultServiceRegistry.class);    private final Map&lt;String, Object&gt; serviceMap = new ConcurrentHashMap&lt;&gt;();    private final Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();    @Override    public synchronized &lt;T&gt; void register(T service) &#123;        String serviceName = service.getClass().getCanonicalName();        if(registeredService.contains(serviceName)) return;        registeredService.add(serviceName);        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();        if(interfaces.length == 0) &#123;            throw new RpcException(RpcError.SERVICE_NOT_IMPLEMENT_ANY_INTERFACE);        &#125;        for(Class&lt;?&gt; i : interfaces) &#123;            serviceMap.put(i.getCanonicalName(), service);        &#125;        logger.info(&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;, interfaces, serviceName);    &#125;    @Override    public synchronized Object getService(String serviceName) &#123;        Object service = serviceMap.get(serviceName);        if(service == null) &#123;            throw new RpcException(RpcError.SERVICE_NOT_FOUND);        &#125;        return service;    &#125;&#125;\n\n我们将服务名与提供服务的对象的对应关系保存在一个 ConcurrentHashMap 中，并且使用一个 Set 来保存当前有哪些对象已经被注册。\n在注册服务时，默认采用这个对象实现的接口的完整类名作为服务名，例如某个对象 A 实现了接口 X 和 Y，那么将 A 注册进去后，会有两个服务名 X 和 Y 对应于 A 对象。这种处理方式也就说明了某个接口只能有一个对象提供服务。\n2.2、其他处理为了降低耦合度，我们不会把 ServiceRegistry 和某一个 RpcServer 绑定在一起，而是在创建 RpcServer 对象时，传入一个 ServiceRegistry 作为这个服务的注册表。\n那么 RpcServer 这个类现在就变成了这样：\npublic class RpcServer &#123;    private static final Logger logger = LoggerFactory.getLogger(RpcServer.class);    private static final int CORE_POOL_SIZE = 5;    private static final int MAXIMUM_POOL_SIZE = 50;    private static final int KEEP_ALIVE_TIME = 60;    private static final int BLOCKING_QUEUE_CAPACITY = 100;    private final ExecutorService threadPool;    private RequestHandler requestHandler = new RequestHandler();    private final ServiceRegistry serviceRegistry;    public RpcServer(ServiceRegistry serviceRegistry) &#123;        this.serviceRegistry = serviceRegistry;        BlockingQueue&lt;Runnable&gt; workingQueue = new ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);        ThreadFactory threadFactory = Executors.defaultThreadFactory();        threadPool = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, workingQueue, threadFactory);    &#125;    public void start(int port) &#123;        try (ServerSocket serverSocket = new ServerSocket(port)) &#123;            logger.info(&quot;服务器启动……&quot;);            Socket socket;            while((socket = serverSocket.accept()) != null) &#123;                logger.info(&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;, socket.getInetAddress(), socket.getPort());                threadPool.execute(new RequestHandlerThread(socket, requestHandler, serviceRegistry));            &#125;            threadPool.shutdown();        &#125; catch (IOException e) &#123;            logger.error(&quot;服务器启动时有错误发生:&quot;, e);        &#125;    &#125;&#125;\n\n在创建 RpcServer 时需要传入一个已经注册好服务的 ServiceRegistry，而原来的 register 方法也被改成了 start 方法，因为服务的注册已经不由 RpcServer 处理了，它只需要启动就行了。\n而在每一个请求处理线程（RequestHandlerThread）中也就需要传入 ServiceRegistry 了，这里把处理线程和处理逻辑分成了两个类：RequestHandlerThread 只是一个线程，从ServiceRegistry 获取到提供服务的对象后，就会把 RpcRequest 和服务对象直接交给 RequestHandler 去处理，反射等过程被放到了 RequestHandler 里。\nRequesthandlerThread.java：处理线程，接受对象等\npublic class RequestHandlerThread implements Runnable &#123;    private static final Logger logger = LoggerFactory.getLogger(RequestHandlerThread.class);    private Socket socket;    private RequestHandler requestHandler;    private ServiceRegistry serviceRegistry;    public RequestHandlerThread(Socket socket, RequestHandler requestHandler, ServiceRegistry serviceRegistry) &#123;        this.socket = socket;        this.requestHandler = requestHandler;        this.serviceRegistry = serviceRegistry;    &#125;    @Override    public void run() &#123;        try (ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());             ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream())) &#123;            RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();            String interfaceName = rpcRequest.getInterfaceName();            Object service = serviceRegistry.getService(interfaceName);            Object result = requestHandler.handle(rpcRequest, service);            objectOutputStream.writeObject(RpcResponse.success(result));            objectOutputStream.flush();        &#125; catch (IOException | ClassNotFoundException e) &#123;            logger.error(&quot;调用或发送时有错误发生：&quot;, e);        &#125;    &#125;&#125;\n\n\n\nRequestHandler.java：通过反射进行方法调用\npublic class RequestHandler &#123;    private static final Logger logger = LoggerFactory.getLogger(RequestHandler.class);    public Object handle(RpcRequest rpcRequest, Object service) &#123;        Object result = null;        try &#123;            result = invokeTargetMethod(rpcRequest, service);            logger.info(&quot;服务:&#123;&#125; 成功调用方法:&#123;&#125;&quot;, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;            logger.error(&quot;调用或发送时有错误发生：&quot;, e);        &#125; return result;    &#125;    private Object invokeTargetMethod(RpcRequest rpcRequest, Object service) throws IllegalAccessException, InvocationTargetException &#123;        Method method;        try &#123;            method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());        &#125; catch (NoSuchMethodException e) &#123;            return RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND);        &#125;        return method.invoke(service, rpcRequest.getParameters());    &#125;&#125;\n\n\n\n在这种情况下，客户端完全不需要做任何改动。\n2.3、测试服务端的测试\npublic class TestServer &#123;    public static void main(String[] args) &#123;        HelloService helloService = new HelloServiceImpl();        ServiceRegistry serviceRegistry = new DefaultServiceRegistry();        serviceRegistry.register(helloService);        RpcServer rpcServer = new RpcServer(serviceRegistry);        rpcServer.start(9000);    &#125;&#125;\n\n\n\n\n\n3、Netty传输和通用序列化接口本节我们会将传统的 BIO 方式传输换成效率更高的 NIO 方式，当然不会使用 Java 原生的 NIO，而是采用更为简单的 Netty。本节还会实现一个通用的序列化接口，为多种序列化支持做准备，并且，本节还会自定义传输的协议。\n3.1、Netty 服务端与客户端首先就需要在 pom.xml 中加入 Netty 依赖：\n&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;/groupId&gt;    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;\t&lt;version&gt;$&#123;netty-version&#125;&lt;/version&gt;&lt;/dependency&gt;\n\nnetty 的最新版本可以在 mavenrepository查到，注意使用 netty 4 而不是 netty 5。\n为了保证通用性，我们可以把 Server 和 Client 抽象成两个接口，分别是 RpcServer 和 RpcClient：\npublic interface RpcServer &#123;    void start(int port);&#125;public interface RpcClient &#123;    Object sendRequest(RpcRequest rpcRequest);&#125;\n\n而原来的 RpcServer 和 RpcClient 类实际上是上述两个接口的 Socket 方式实现类，改成 SocketServer 和 SocketClient 并实现上面两个接口即可，几乎不需要做什么修改。\n我们的任务，就是要实现 NettyServer 和 NettyClient。\n这里提一个改动，就是在 DefaultServiceRegistry.java 中，将包含注册信息的 serviceMap 和 registeredService 都改成了 static ，这样就能保证全局唯一的注册信息，并且在创建 RpcServer 时也就不需要传入了。\nNettyServer的实现很传统\npublic class NettyServer implements RpcServer &#123;    private static final Logger logger = LoggerFactory.getLogger(NettyServer.class);    @Override    public void start(int port) &#123;        EventLoopGroup bossGroup = new NioEventLoopGroup();        EventLoopGroup workerGroup = new NioEventLoopGroup();        try &#123;            ServerBootstrap serverBootstrap = new ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .handler(new LoggingHandler(LogLevel.INFO))                    .option(ChannelOption.SO_BACKLOG, 256)                    .option(ChannelOption.SO_KEEPALIVE, true)                    .childOption(ChannelOption.TCP_NODELAY, true)                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            ChannelPipeline pipeline = ch.pipeline();                            pipeline.addLast(new CommonEncoder(new JsonSerializer()));                            pipeline.addLast(new CommonDecoder());                            pipeline.addLast(new NettyServerHandler());                        &#125;                    &#125;);            ChannelFuture future = serverBootstrap.bind(port).sync();            future.channel().closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            logger.error(&quot;启动服务器时有错误发生: &quot;, e);        &#125; finally &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;\n\n了解过 Netty 的同学可能知道，Netty 中有一个很重要的设计模式——责任链模式，责任链上有多个处理器，每个处理器都会对数据进行加工，并将处理后的数据传给下一个处理器。代码中的 CommonEncoder、CommonDecoder和NettyServerHandler 分别就是编码器，解码器和数据处理器。因为数据从外部传入时需要解码，而传出时需要编码，类似计算机网络的分层模型，每一层向下层传递数据时都要加上该层的信息，而向上层传递时则需要对本层信息进行解码。\n而 NettyClient 的实现也很类似：\npublic class NettyClient implements RpcClient &#123;    private static final Logger logger = LoggerFactory.getLogger(NettyClient.class);    private String host;    private int port;    private static final Bootstrap bootstrap;    public NettyClient(String host, int port) &#123;        this.host = host;        this.port = port;    &#125;    static &#123;        EventLoopGroup group = new NioEventLoopGroup();        bootstrap = new Bootstrap();        bootstrap.group(group)                .channel(NioSocketChannel.class)                .option(ChannelOption.SO_KEEPALIVE, true)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel ch) throws Exception &#123;                        ChannelPipeline pipeline = ch.pipeline();                        pipeline.addLast(new CommonDecoder())                                .addLast(new CommonEncoder(new JsonSerializer()))                                .addLast(new NettyClientHandler());                    &#125;                &#125;);    &#125;    @Override    public Object sendRequest(RpcRequest rpcRequest) &#123;        try &#123;            ChannelFuture future = bootstrap.connect(host, port).sync();            logger.info(&quot;客户端连接到服务器 &#123;&#125;:&#123;&#125;&quot;, host, port);            Channel channel = future.channel();            if(channel != null) &#123;                channel.writeAndFlush(rpcRequest).addListener(future1 -&gt; &#123;                    if(future1.isSuccess()) &#123;                        logger.info(String.format(&quot;客户端发送消息: %s&quot;, rpcRequest.toString()));                    &#125; else &#123;                        logger.error(&quot;发送消息时有错误发生: &quot;, future1.cause());                    &#125;                &#125;);                channel.closeFuture().sync();                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(&quot;rpcResponse&quot;);                RpcResponse rpcResponse = channel.attr(key).get();                return rpcResponse.getData();            &#125;        &#125; catch (InterruptedException e) &#123;            logger.error(&quot;发送消息时有错误发生: &quot;, e);        &#125;        return null;    &#125;&#125;\n\n在静态代码块中就直接配置好了 Netty 客户端，等待发送数据时启动，channel 将 RpcRequest 对象写出，并且等待服务端返回的结果。注意这里的发送是非阻塞的，所以发送后会立刻返回，而无法得到结果。这里通过 AttributeKey 的方式阻塞获得返回结果：\nAttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(&quot;rpcResponse&quot;);RpcResponse rpcResponse = channel.attr(key).get();\n\n通过这种方式获得全局可见的返回结果，在获得返回结果 RpcResponse 后，将这个对象以 key 为 rpcResponse 放入 ChannelHandlerContext 中，这里就可以立刻获得结果并返回，我们会在 NettyClientHandler 中看到放入的过程。\n3.2、自定义协议与编解码器在传输过程中，我们可以在发送的数据上加上各种必要的数据，形成自定义的协议，而自动加上这个数据就是编码器的工作，解析数据获得原始数据就是解码器的工作。\n我们定义的协议是这样的：\n+---------------+---------------+-----------------+-------------+|  Magic Number |  Package Type | Serializer Type | Data Length ||    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |+---------------+---------------+-----------------+-------------+|                          Data Bytes                           ||                   Length: $&#123;Data Length&#125;                      |+---------------------------------------------------------------+\n\n首先是 4 字节魔数，表识一个协议包。接着是 Package Type，标明这是一个调用请求还是调用响应，Serializer Type 标明了实际数据使用的序列化器，这个服务端和客户端应当使用统一标准；Data Length 就是实际数据的长度，设置这个字段主要防止粘包，最后就是经过序列化后的实际数据，可能是 RpcRequest 也可能是 RpcResponse 经过序列化后的字节，取决于 Package Type。\n规定好协议后，我们就可以来看看 CommonEncoder 了：\npublic class CommonEncoder extends MessageToByteEncoder &#123;    private static final int MAGIC_NUMBER = 0xCAFEBABE;    private final CommonSerializer serializer;    public CommonEncoder(CommonSerializer serializer) &#123;        this.serializer = serializer;    &#125;    @Override    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception &#123;        out.writeInt(MAGIC_NUMBER);        if(msg instanceof RpcRequest) &#123;            out.writeInt(PackageType.REQUEST_PACK.getCode());        &#125; else &#123;            out.writeInt(PackageType.RESPONSE_PACK.getCode());        &#125;        out.writeInt(serializer.getCode());        byte[] bytes = serializer.serialize(msg);        out.writeInt(bytes.length);        out.writeBytes(bytes);    &#125;&#125;\n\nCommonEncoder 继承了MessageToByteEncoder 类，见名知义，就是把 Message（实际要发送的对象）转化成 Byte 数组。CommonEncoder 的工作很简单，就是把 RpcRequest 或者 RpcResponse 包装成协议包。 根据上面提到的协议格式，将各个字段写到管道里就可以了，这里serializer.getCode() 获取序列化器的编号，之后使用传入的序列化器将请求或响应包序列化为字节数组写入管道即可。\n而 CommonDecoder 的工作就更简单了：\npublic class CommonDecoder extends ReplayingDecoder &#123;    private static final Logger logger = LoggerFactory.getLogger(CommonDecoder.class);    private static final int MAGIC_NUMBER = 0xCAFEBABE;    @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;        int magic = in.readInt();        if(magic != MAGIC_NUMBER) &#123;            logger.error(&quot;不识别的协议包: &#123;&#125;&quot;, magic);            throw new RpcException(RpcError.UNKNOWN_PROTOCOL);        &#125;        int packageCode = in.readInt();        Class&lt;?&gt; packageClass;        if(packageCode == PackageType.REQUEST_PACK.getCode()) &#123;            packageClass = RpcRequest.class;        &#125; else if(packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;            packageClass = RpcResponse.class;        &#125; else &#123;            logger.error(&quot;不识别的数据包: &#123;&#125;&quot;, packageCode);            throw new RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);        &#125;        int serializerCode = in.readInt();        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);        if(serializer == null) &#123;            logger.error(&quot;不识别的反序列化器: &#123;&#125;&quot;, serializerCode);            throw new RpcException(RpcError.UNKNOWN_SERIALIZER);        &#125;        int length = in.readInt();        byte[] bytes = new byte[length];        in.readBytes(bytes);        Object obj = serializer.deserialize(bytes, packageClass);        out.add(obj);    &#125;&#125;\n\nCommonDecoder 继承自 ReplayingDecoder ，与 MessageToByteEncoder 相反，它用于将收到的字节序列还原为实际对象。主要就是一些字段的校验，比较重要的就是取出序列化器的编号，以获得正确的反序列化方式，并且读入 length 字段来确定数据包的长度（防止粘包），最后读入正确大小的字节数组，反序列化成对应的对象。\n3.3、序列化接口序列化器接口（CommonSerializer）如下：\npublic interface CommonSerializer &#123;    byte[] serialize(Object obj);    Object deserialize(byte[] bytes, Class&lt;?&gt; clazz);    int getCode();    static CommonSerializer getByCode(int code) &#123;        switch (code) &#123;            case 1:                return new JsonSerializer();            default:                return null;        &#125;    &#125;&#125;\n\n主要就是四个方法，序列化，反序列化，获得该序列化器的编号，以及根据编号获取序列化器，这里我已经写了一个示例的 JSON 序列化器，Kryo 序列化器会在后面讲解。\n作为一个比较简单的例子，我写了一个 JSON 的序列化器：\npublic class JsonSerializer implements CommonSerializer &#123;    private static final Logger logger = LoggerFactory.getLogger(JsonSerializer.class);    private ObjectMapper objectMapper = new ObjectMapper();    @Override    public byte[] serialize(Object obj) &#123;        try &#123;            return objectMapper.writeValueAsBytes(obj);        &#125; catch (JsonProcessingException e) &#123;            logger.error(&quot;序列化时有错误发生: &#123;&#125;&quot;, e.getMessage());            e.printStackTrace();            return null;        &#125;    &#125;    @Override    public Object deserialize(byte[] bytes, Class&lt;?&gt; clazz) &#123;        try &#123;            Object obj = objectMapper.readValue(bytes, clazz);            if(obj instanceof RpcRequest) &#123;                obj = handleRequest(obj);            &#125;            return obj;        &#125; catch (IOException e) &#123;            logger.error(&quot;反序列化时有错误发生: &#123;&#125;&quot;, e.getMessage());            e.printStackTrace();            return null;        &#125;    &#125;    /*        这里由于使用JSON序列化和反序列化Object数组，无法保证反序列化后仍然为原实例类型        需要重新判断处理     */    private Object handleRequest(Object obj) throws IOException &#123;        RpcRequest rpcRequest = (RpcRequest) obj;        for(int i = 0; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;            Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];            if(!clazz.isAssignableFrom(rpcRequest.getParameters()[i].getClass())) &#123;                byte[] bytes = objectMapper.writeValueAsBytes(rpcRequest.getParameters()[i]);                rpcRequest.getParameters()[i] = objectMapper.readValue(bytes, clazz);            &#125;        &#125;        return rpcRequest;    &#125;    @Override    public int getCode() &#123;        return SerializerCode.valueOf(&quot;JSON&quot;).getCode();    &#125;&#125;\n\nJSON 序列化工具我使用的是 Jackson，在 pom.xml 中添加依赖即可。序列化和反序列化都比较循规蹈矩，把对象翻译成字节数组，和根据字节数组和 Class 反序列化成对象。这里有一个需要注意的点，就是在 RpcRequest 反序列化时，由于其中有一个字段是 Object 数组，在反序列化时序列化器会根据字段类型进行反序列化，而 Object 就是一个十分模糊的类型，会出现反序列化失败的现象，这时就需要 RpcRequest 中的另一个字段 ParamTypes 来获取到 Object 数组中的每个实例的实际类，辅助反序列化，这就是 handleRequest() 方法的作用。\n上面提到的这种情况不会在其他序列化方式中出现，因为其他序列化方式是转换成字节数组，会记录对象的信息，而 JSON 方式本质上只是转换成 JSON 字符串，会丢失对象的类型信息。\n3.4、NettyServerHandler 和 NettyClientHandlerNettyServerHandler 和 NettyClientHandler 都分别位于服务器端和客户端责任链的尾部，直接和 RpcServer 对象或 RpcClient 对象打交道，而无需关心字节序列的情况。\nNettyServerhandler 用于接收 RpcRequest，并且执行调用，将调用结果返回封装成 RpcResponse 发送出去。\npublic class NettyServerHandler extends SimpleChannelInboundHandler&lt;RpcRequest&gt; &#123;    private static final Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);    private static RequestHandler requestHandler;    private static ServiceRegistry serviceRegistry;    static &#123;        requestHandler = new RequestHandler();        serviceRegistry = new DefaultServiceRegistry();    &#125;    @Override    protected void channelRead0(ChannelHandlerContext ctx, RpcRequest msg) throws Exception &#123;        try &#123;            logger.info(&quot;服务器接收到请求: &#123;&#125;&quot;, msg);            String interfaceName = msg.getInterfaceName();            Object service = serviceRegistry.getService(interfaceName);            Object result = requestHandler.handle(msg, service);            ChannelFuture future = ctx.writeAndFlush(RpcResponse.success(result));            future.addListener(ChannelFutureListener.CLOSE);        &#125; finally &#123;            ReferenceCountUtil.release(msg);        &#125;    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        logger.error(&quot;处理过程调用时有错误发生:&quot;);        cause.printStackTrace();        ctx.close();    &#125;&#125;\n\n处理方式和 Socket 中的逻辑基本一致，不做讲解。\nNettyClientHandler\npublic class NettyClientHandler extends SimpleChannelInboundHandler&lt;RpcResponse&gt; &#123;    private static final Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);    @Override    protected void channelRead0(ChannelHandlerContext ctx, RpcResponse msg) throws Exception &#123;        try &#123;            logger.info(String.format(&quot;客户端接收到消息: %s&quot;, msg));            AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(&quot;rpcResponse&quot;);            ctx.channel().attr(key).set(msg);            ctx.channel().close();        &#125; finally &#123;            ReferenceCountUtil.release(msg);        &#125;    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        logger.error(&quot;过程调用时有错误发生:&quot;);        cause.printStackTrace();        ctx.close();    &#125;&#125;\n\n这里只需要处理收到的消息，即 RpcResponse 对象，由于前面已经有解码器解码了，这里就直接将返回的结果放入 ctx 中即可。\n3.5、测试这里我们主要测试 Netty 方式。\nNettyTestServer 如下：\npublic class NettyTestServer &#123;    public static void main(String[] args) &#123;        HelloService helloService = new HelloServiceImpl();        ServiceRegistry registry = new DefaultServiceRegistry();        registry.register(helloService);        NettyServer server = new NettyServer();        server.start(9999);    &#125;&#125;\n\nNettyTestClient如下：\npublic class NettyTestClient &#123;    public static void main(String[] args) &#123;        RpcClient client = new NettyClient(&quot;127.0.0.1&quot;, 9999);        RpcClientProxy rpcClientProxy = new RpcClientProxy(client);        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);        HelloObject object = new HelloObject(12, &quot;This is a message&quot;);        String res = helloService.hello(object);        System.out.println(res);    &#125;&#125;\n\n注意这里 RpcClientProxy 通过传入不同的 Client（SocketClient、NettyClient）来切换客户端不同的发送方式。\n执行后可以获得与之前类似的结果。\n4、Kryo序列化上一节我们实现了一个通用的序列化框架，使得序列化方式具有了较高的扩展性，并且实现了一个基于 JSON 的序列化器。\n但是，我们也提到过，这个基于 JSON 的序列化器有一个毛病，就是在某个类的属性反序列化时，如果属性声明为 Object 的，就会造成反序列化出错，通常会把 Object 属性直接反序列化成 String 类型，就需要其他参数辅助序列化。并且，JSON 序列化器是基于字符串（JSON 串）的，占用空间较大且速度较慢。\n另外，我们在用过的RPC通信框架中，很少会发现使用JDK提供的序列化，主要是因为JDK默认的序列化存在着如下一些缺陷：无法跨语言、易被攻击、序列化后的流太大、序列化性能太差等。\n这一节我们就来实现一个基于 Kryo 的序列化器。那么，什么是 Kryo？\nKryo 是一个快速高效的 Java 对象序列化框架，主要特点是高性能、高效和易用。最重要的两个特点，一是基于字节的序列化，对空间利用率较高，在网络传输时可以减小体积；二是序列化时记录属性对象的类型信息，这样在反序列化时就不会出现之前的问题了。\n4.1、实现接口首先添加 kryo 的依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;    &lt;artifactId&gt;kryo&lt;/artifactId&gt;    &lt;version&gt;4.0.2&lt;/version&gt;&lt;/dependency&gt;\n\n我们在上一节定义了一个通用的序列化接口：\npublic interface CommonSerializer &#123;    byte[] serialize(Object obj);    Object deserialize(byte[] bytes, Class&lt;?&gt; clazz);    int getCode();    static CommonSerializer getByCode(int code) &#123;        switch (code) &#123;            case 0:                return new KryoSerializer();            case 1:                return new JsonSerializer();            default:                return null;        &#125;    &#125;&#125;\n\n根据接口，我们的主要任务就是实现其中的主要两个方法，serialize() 和 deserialize() ，如下：\npublic class KryoSerializer implements CommonSerializer &#123;    private static final Logger logger = LoggerFactory.getLogger(KryoSerializer.class);    private static final ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;        Kryo kryo = new Kryo();        kryo.register(RpcResponse.class);        kryo.register(RpcRequest.class);        kryo.setReferences(true);        kryo.setRegistrationRequired(false);        return kryo;    &#125;);    @Override    public byte[] serialize(Object obj) &#123;        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();             Output output = new Output(byteArrayOutputStream))&#123;            Kryo kryo = kryoThreadLocal.get();            kryo.writeObject(output, obj);            kryoThreadLocal.remove();            return output.toBytes();        &#125; catch (Exception e) &#123;            logger.error(&quot;序列化时有错误发生:&quot;, e);            throw new SerializeException(&quot;序列化时有错误发生&quot;);        &#125;    &#125;    @Override    public Object deserialize(byte[] bytes, Class&lt;?&gt; clazz) &#123;        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);            Input input = new Input(byteArrayInputStream)) &#123;            Kryo kryo = kryoThreadLocal.get();            Object o = kryo.readObject(input, clazz);            kryoThreadLocal.remove();            return o;        &#125; catch (Exception e) &#123;            logger.error(&quot;反序列化时有错误发生:&quot;, e);            throw new SerializeException(&quot;反序列化时有错误发生&quot;);        &#125;    &#125;    @Override    public int getCode() &#123;        return SerializerCode.valueOf(&quot;KRYO&quot;).getCode();    &#125;&#125;\n\n这里 Kryo 可能存在线程安全问题，文档上是推荐放在 ThreadLocal 里，一个线程一个 Kryo。在序列化时，先创建一个 Output 对象（Kryo 框架的概念），接着使用 writeObject 方法将对象写入 Output 中，最后调用 Output 对象的 toByte() 方法即可获得对象的字节数组。反序列化则是从 Input 对象中直接 readObject，这里只需要传入对象的类型，而不需要具体传入每一个属性的类型信息。\n最后 getCode 方法中事实上是把序列化的编号写在一个枚举类 SerializerCode 里了：\npublic enum SerializerCode &#123;    KRYO(0),    JSON(1);    private final int code;&#125;\n\n4.2、替换序列化器并测试我们只需要把 NettyServer 和 NettyClient 责任链中的 CommonEncoder 传入的参数改成 KryoSerializer 即可使用 Kryo 序列化。\n-                             pipeline.addLast(new CommonEncoder(new JsonSerializer()));+                             pipeline.addLast(new CommonEncoder(new KryoSerializer()));\n\n\n\n5、基于 Nacos 的服务器注册与发现我们目前实现的框架看起来工作的还不错，但是有一个问题：我们的服务端地址是固化在代码中的，也就是说，对于一个客户端，它只会去寻找那么一个服务提供者，如果这个提供者挂了或者换了地址，那就没有办法了。\n在分布式架构中，有一个重要的组件，就是服务注册中心，它用于保存多个服务提供者的信息，每个服务提供者在启动时都需要向注册中心注册自己所拥有的服务。这样客户端在发起 RPC 时，就可以直接去向注册中心请求服务提供者的信息，如果拿来的这个挂了，还可以重新请求，并且在这种情况下可以很方便地实现负载均衡。\n常见的注册中心有 Eureka、Zookeeper 和 Nacos。\n获得 Nacos\nNacos 是阿里开发的一款服务注册中心，在 SpringCloud Alibaba 逐步替代原始的 SpringCloud 的过程中，Nacos 逐步走红，所以我们就是用 Nacos 作为我们的注册中心。\n下载解压的过程略过。注意 Nacos 是依赖数据库的，所以我们需要在配置文件中配置 Mysql 的信息。\n为了简单，我们先以单机模式运行：\nsh startup.sh -m standalone\n\n启动后可以访问 Nacos 的web UI，地址 http://127.0.0.1:8848/nacos/index.html\n默认的用户名和密码都是 nacos\n5.1、在项目中使用 Nacos引入 nacos-client 依赖：\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;    &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;    &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;\n\n这里我们修正之前的概念，第二节把本地保存服务的类称为 ServiceRegistry，现在更改为 ServiceProvider，而 ServiceRegistry 作为远程注册表（Nacos）使用，对应的类名也有修改。\n这里我们实现一个接口 ServiceRegistry：\npublic interface ServiceRegistry &#123;    void register(String serviceName, InetSocketAddress inetSocketAddress);    InetSocketAddress lookupService(String serviceName);&#125;\n\n两个方法很好理解，register 方法将服务的名称和地址注册进服务注册中心，lookupService 方法则是根据服务名称从注册中心获取到一个服务提供者的地址。\n接口有了，我们就可以写实现类了，我们实现一个 Nacos 作为注册中心的实现类：NacosServiceRegistry，我们也可以使用 ZooKeeper 作为注册中心，实现接口就可以\npublic class NacosServiceRegistry implements ServiceRegistry &#123;    private static final Logger logger = LoggerFactory.getLogger(NacosServiceRegistry.class);    private static final String SERVER_ADDR = &quot;127.0.0.1:8848&quot;;    private static final NamingService namingService;    static &#123;        try &#123;            namingService = NamingFactory.createNamingService(SERVER_ADDR);        &#125; catch (NacosException e) &#123;            logger.error(&quot;连接到Nacos时有错误发生: &quot;, e);            throw new RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);        &#125;m,.    &#125;    @Override    public void register(String serviceName, InetSocketAddress inetSocketAddress) &#123;        try &#123;            namingService.registerInstance(serviceName, inetSocketAddress.getHostName(), inetSocketAddress.getPort());        &#125; catch (NacosException e) &#123;            logger.error(&quot;注册服务时有错误发生:&quot;, e);            throw new RpcException(RpcError.REGISTER_SERVICE_FAILED);        &#125;    &#125;    @Override    public InetSocketAddress lookupService(String serviceName) &#123;        try &#123;            List&lt;Instance&gt; instances = namingService.getAllInstances(serviceName);            Instance instance = instances.get(0);            return new InetSocketAddress(instance.getIp(), instance.getPort());        &#125; catch (NacosException e) &#123;            logger.error(&quot;获取服务时有错误发生:&quot;, e);        &#125;        return null;    &#125;&#125;\n\nNacos 的使用很简单，通过 NamingFactory 创建 NamingService 连接 Nacos（连接的时候没有找到修改用户名密码的方式……是不需要吗），连接的过程写在了静态代码块中，在类加载时自动连接。namingService 提供了两个很方便的接口，registerInstance 和 getAllInstances 方法，前者可以直接向 Nacos 注册服务，后者可以获得提供某个服务的所有提供者的列表。所以接口的这两个方法只需要包装一下就好了。\n在 lookupService 方法中，通过 getAllInstance 获取到某个服务的所有提供者列表后，需要选择一个，这里就涉及了负载均衡策略，这里我们先选择第 0 个，后面某节会详细讲解负载均衡。\n5.2、注册服务我们修改 RpcServer 接口，新增一个方法 publishService，用于向 Nacos 注册服务：\n&lt;T&gt; void publishService(Object service, Class&lt;T&gt; serviceClass);\n\n接着只需要实现这个方法即可，以 NettyServer 的实现为例，NettyServer 在创建时需要创建一个 ServiceRegistry 了：\npublic NettyServer(String host, int port) &#123;    this.host = host;    this.port = port;    serviceRegistry = new NacosServiceRegistry();    serviceProvider = new ServiceProviderImpl();&#125;\n\n接着实现 publishService 方法即可：\npublic &lt;T&gt; void publishService(Object service, Class&lt;T&gt; serviceClass) &#123;    if(serializer == null) &#123;        logger.error(&quot;未设置序列化器&quot;);        throw new RpcException(RpcError.SERIALIZER_NOT_FOUND);    &#125;    serviceProvider.addServiceProvider(service);    serviceRegistry.register(serviceClass.getCanonicalName(), new InetSocketAddress(host, port));    start();&#125;\n\npublishService 需要将服务保存在本地的注册表，同时注册到 Nacos 上。我这里的实现是注册完一个服务后直接调用 start() 方法，这是个不太好的实现……导致一个服务端只能注册一个服务，之后可以多注册几个然后再手动调用 start() 方法。\n5.3、发现服务客户端的修改就更简单了，以 NettyClient 为例，在过去创建 NettyClient 时，需要传入 host 和 port，现在这个 host 和 port 是通过 Nacos 获取的，sendRequest 修改如下：\npublic Object sendRequest(RpcRequest rpcRequest) &#123;        if(serializer == null) &#123;            logger.error(&quot;未设置序列化器&quot;);            throw new RpcException(RpcError.SERIALIZER_NOT_FOUND);        &#125;        AtomicReference&lt;Object&gt; result = new AtomicReference&lt;&gt;(null);        try &#123;            InetSocketAddress inetSocketAddress = serviceRegistry.lookupService(rpcRequest.getInterfaceName());            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);...\n\n重点是最后两句，过去是直接使用传入的 host 和 port 直接构造 channel，现在是首先从 ServiceRegistry 中获取到服务的地址和端口，再构造。\n5.4、测试NettyTestClient 如下：\npublic class NettyTestClient &#123;    public static void main(String[] args) &#123;        RpcClient client = new NettyClient();        client.setSerializer(new ProtobufSerializer());        RpcClientProxy rpcClientProxy = new RpcClientProxy(client);        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);        HelloObject object = new HelloObject(12, &quot;This is a message&quot;);        String res = helloService.hello(object);        System.out.println(res);    &#125;&#125;\n\n构造 RpcClient 时不再需要传入地址和端口。\nNettyTestServer 如下：\npublic class NettyTestServer &#123;    public static void main(String[] args) &#123;        HelloService helloService = new HelloServiceImpl();        NettyServer server = new NettyServer(&quot;127.0.0.1&quot;, 9999);        server.setSerializer(new ProtobufSerializer());        server.publishService(helloService, HelloService.class);    &#125;&#125;\n\n我这里是把 start 写在了 publishService 中，实际应当分离，否则只能注册一个服务。\n分别启动，可以看到和之前相同的结果。\n这里如果通过修改不同的端口，启动两个服务的话，会看到即使客户端多次调用，也只是由同一个服务端提供服务，这是因为在 NacosServiceRegistry 中，我们直接选择了服务列表的第 0 个，这个会在之后讲解负载均衡时作出修改。\n6、自动注销服务和负载均衡策略6.1、自动注销服务上一节我们实现了服务的自动注册和发现，但是有些细心的同学就可能会发现，如果你启动完成服务端后把服务端给关闭了，并不会自动地注销 Nacos 中对应的服务信息，这样就导致了当客户端再次向 Nacos 请求服务时，会获取到已经关闭的服务端信息，最终就有可能因为连接不到服务器而调用失败。\n那么我们就需要一种办法，在服务端关闭之前自动向 Nacos 注销服务。但是有一个问题，我们不知道什么时候服务器会关闭，也就不知道这个方法调用的时机，就没有办法手工去调用。这时，我们就需要钩子。\n钩子是什么呢？是在某些事件发生后自动去调用的方法。那么我们只需要把注销服务的方法写到关闭系统的钩子方法里就行了。\n首先先写向 Nacos 注销所有服务的方法，这部分被放在了 NacosUtils 中作为一个静态方法，NacosUtils 是一个 Nacos 相关的工具类：\npublic static void clearRegistry() &#123;    if(!serviceNames.isEmpty() &amp;&amp; address != null) &#123;        String host = address.getHostName();        int port = address.getPort();        Iterator&lt;String&gt; iterator = serviceNames.iterator();        while(iterator.hasNext()) &#123;            String serviceName = iterator.next();            try &#123;                namingService.deregisterInstance(serviceName, host, port);            &#125; catch (NacosException e) &#123;                logger.error(&quot;注销服务 &#123;&#125; 失败&quot;, serviceName, e);            &#125;        &#125;    &#125;&#125;\n\n所有的服务名称都被存储在 NacosUtils 类中的 serviceNames 中，在注销时只需要用迭代器迭代所有服务名，调用 deregisterInstance 即可。\n接着就是钩子了，新建一个类，ShutdownHook：\npublic class ShutdownHook &#123;    private static final Logger logger = LoggerFactory.getLogger(ShutdownHook.class);    private final ExecutorService threadPool = ThreadPoolFactory.createDefaultThreadPool(&quot;shutdown-hook&quot;);    private static final ShutdownHook shutdownHook = new ShutdownHook();    public static ShutdownHook getShutdownHook() &#123;        return shutdownHook;    &#125;    public void addClearAllHook() &#123;        logger.info(&quot;关闭后将自动注销所有服务&quot;);        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;            NacosUtil.clearRegistry();            threadPool.shutdown();        &#125;));    &#125;&#125;\n\n使用了单例模式创建其对象，在 addClearAllHook 中，Runtime 对象是 JVM 虚拟机的运行时环境，调用其 addShutdownHook 方法增加一个钩子函数，创建一个新线程调用 clearRegistry 方法完成注销工作。这个钩子函数会在 JVM 关闭之前被调用。\n这样在 RpcServer 启动之前，只需要调用 addClearAllHook，就可以注册这个钩子了。例如在 NettyServer 中：\n             ChannelFuture future = serverBootstrap.bind(host, port).sync();+            ShutdownHook.getShutdownHook().addClearAllHook();             future.channel().closeFuture().sync();\n\n启动服务端后再关闭，就会发现 Nacos 中的注册信息都被注销了。\n6.2、负载均衡策略负载均衡大家应该都熟悉，在上一节中客户端在 lookupService 方法中，从 Nacos 获取到的是所有提供这个服务的服务端信息列表，我们就需要从中选择一个，这便涉及到客户端侧的负载均衡策略。我们新建一个接口：LoadBalancer：\npublic interface LoadBalancer &#123;    Instance select(List&lt;Instance&gt; instances);&#125;\n\n接口中的 select 方法用于从一系列 Instance 中选择一个。这里我就实现两个比较经典的算法：随机和转轮。\n随机算法顾名思义，就是随机选一个，毫无技术含量：\npublic class RandomLoadBalancer implements LoadBalancer &#123;    @Override    public Instance select(List&lt;Instance&gt; instances) &#123;        return instances.get(new Random().nextInt(instances.size()));    &#125;&#125;\n\n而转轮算法大家也应该了解，按照顺序依次选择第一个、第二个、第三个……这里就需要一个变量来表示当前选到了第几个：\npublic class RoundRobinLoadBalancer implements LoadBalancer &#123;    private int index = 0;    @Override    public Instance select(List&lt;Instance&gt; instances) &#123;        if(index &gt;= instances.size()) &#123;            index %= instances.size();        &#125;        return instances.get(index++);    &#125;&#125;\n\nindex 就表示当前选到了第几个服务器，并且每次选择后都会自增一。\n最后在 NacosServiceRegistry 中集成就可以了，这里选择外部传入的方式传入 LoadBalancer：\npublic class NacosServiceDiscovery implements ServiceDiscovery &#123;    private final LoadBalancer loadBalancer;    public NacosServiceDiscovery(LoadBalancer loadBalancer) &#123;        if(loadBalancer == null) this.loadBalancer = new RandomLoadBalancer();        else this.loadBalancer = loadBalancer;    &#125;        public InetSocketAddress lookupService(String serviceName) &#123;        try &#123;            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);            Instance instance = loadBalancer.select(instances);            return new InetSocketAddress(instance.getIp(), instance.getPort());        &#125; catch (NacosException e) &#123;            logger.error(&quot;获取服务时有错误发生:&quot;, e);        &#125;        return null;    &#125;&#125;\n\n而这个负载均衡策略，也可以在创建客户端时指定，例如无参构造 NettyClient 时就用默认的策略，也可以有参构造传入策略，具体的实现留给大家。\n7、服务端自动注册服务到目前为止，客户端看起来挺完美了，但是在服务端，我们却需要手动创建服务对象，并且手动进行注册，如果服务端提供了很多服务，这个操作就会变得很繁琐。本节就会介绍如何基于注解进行服务的自动注册。\n本节需要一些反射知识。\n7.1、定义注解首先我们需要定义两个注解：Service 和 ServiceScan：\nService.java\n@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Service &#123;    public String name() default &quot;&quot;;&#125;\n\nServiceScan.java\n@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ServiceScan &#123;    public String value() default &quot;&quot;;&#125;\n\n@Service 放在一个类上，标识这个类提供一个服务，@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围。Service 注解的值定义为该服务的名称，默认值是该类的完整类名，而 ServiceScan 的值定义为扫描范围的根包，默认值为入口类所在的包，扫描时会扫描该包及其子包下所有的类，找到标记有 Service 的类，并注册。\n7.2、工具类 ReflectUtil这个类是一系列工具方法，不做讲解，只说用途，感兴趣的可以研究研究具体实现：\npublic class ReflectUtil &#123;    public static String getStackTrace() &#123;        StackTraceElement[] stack = new Throwable().getStackTrace();        return stack[stack.length - 1].getClassName();    &#125;    public static Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;        Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;();        boolean recursive = true;        String packageDirName = packageName.replace(&#x27;.&#x27;, &#x27;/&#x27;);        Enumeration&lt;URL&gt; dirs;        try &#123;            dirs = Thread.currentThread().getContextClassLoader().getResources(                    packageDirName);            // 循环迭代下去            while (dirs.hasMoreElements()) &#123;                // 获取下一个元素                URL url = dirs.nextElement();                // 得到协议的名称                String protocol = url.getProtocol();                // 如果是以文件的形式保存在服务器上                if (&quot;file&quot;.equals(protocol)) &#123;                    // 获取包的物理路径                    String filePath = URLDecoder.decode(url.getFile(), &quot;UTF-8&quot;);                    // 以文件的方式扫描整个包下的文件 并添加到集合中                    findAndAddClassesInPackageByFile(packageName, filePath,                            recursive, classes);                &#125; else if (&quot;jar&quot;.equals(protocol)) &#123;                    // 如果是jar包文件                    // 定义一个JarFile                    JarFile jar;                    try &#123;                        // 获取jar                        jar = ((JarURLConnection) url.openConnection())                                .getJarFile();                        // 从此jar包 得到一个枚举类                        Enumeration&lt;JarEntry&gt; entries = jar.entries();                        // 同样的进行循环迭代                        while (entries.hasMoreElements()) &#123;                            // 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件                            JarEntry entry = entries.nextElement();                            String name = entry.getName();                            // 如果是以/开头的                            if (name.charAt(0) == &#x27;/&#x27;) &#123;                                // 获取后面的字符串                                name = name.substring(1);                            &#125;                            // 如果前半部分和定义的包名相同                            if (name.startsWith(packageDirName)) &#123;                                int idx = name.lastIndexOf(&#x27;/&#x27;);                                // 如果以&quot;/&quot;结尾 是一个包                                if (idx != -1) &#123;                                    // 获取包名 把&quot;/&quot;替换成&quot;.&quot;                                    packageName = name.substring(0, idx)                                            .replace(&#x27;/&#x27;, &#x27;.&#x27;);                                &#125;                                // 如果可以迭代下去 并且是一个包                                if ((idx != -1) || recursive) &#123;                                    // 如果是一个.class文件 而且不是目录                                    if (name.endsWith(&quot;.class&quot;)                                            &amp;&amp; !entry.isDirectory()) &#123;                                        // 去掉后面的&quot;.class&quot; 获取真正的类名                                        String className = name.substring(                                                packageName.length() + 1, name                                                        .length() - 6);                                        try &#123;                                            // 添加到classes                                            classes.add(Class                                                    .forName(packageName + &#x27;.&#x27;                                                            + className));                                        &#125; catch (ClassNotFoundException e) &#123;                                            // log                                            // .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);                                            e.printStackTrace();                                        &#125;                                    &#125;                                &#125;                            &#125;                        &#125;                    &#125; catch (IOException e) &#123;                        // log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return classes;    &#125;    private static void findAndAddClassesInPackageByFile(String packageName,                                                         String packagePath, final boolean recursive, Set&lt;Class&lt;?&gt;&gt; classes) &#123;        // 获取此包的目录 建立一个File        File dir = new File(packagePath);        // 如果不存在或者 也不是目录就直接返回        if (!dir.exists() || !dir.isDirectory()) &#123;            // log.warn(&quot;用户定义包名 &quot; + packageName + &quot; 下没有任何文件&quot;);            return;        &#125;        // 如果存在 就获取包下的所有文件 包括目录        File[] dirfiles = dir.listFiles(new FileFilter() &#123;            // 自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)            public boolean accept(File file) &#123;                return (recursive &amp;&amp; file.isDirectory())                        || (file.getName().endsWith(&quot;.class&quot;));            &#125;        &#125;);        // 循环所有文件        for (File file : dirfiles) &#123;            // 如果是目录 则继续扫描            if (file.isDirectory()) &#123;                findAndAddClassesInPackageByFile(packageName + &quot;.&quot;                                + file.getName(), file.getAbsolutePath(), recursive,                        classes);            &#125; else &#123;                // 如果是java类文件 去掉后面的.class 只留下类名                String className = file.getName().substring(0,                        file.getName().length() - 6);                try &#123;                    // 添加到集合中去                    //classes.add(Class.forName(packageName + &#x27;.&#x27; + className));                    //经过回复同学的提醒，这里用forName有一些不好，会触发static方法，没有使用classLoader的load干净                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + &#x27;.&#x27; + className));                &#125; catch (ClassNotFoundException e) &#123;                    // log.error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\n主要就是 getClasses 方法，传入一个包名，用于扫描该包及其子包下所有的类，并将其 Class 对象放入一个 Set 中返回。\n7.3、扫描服务由于扫描服务这一步是一个比较公共的方法，无论是 Socket 还是 Netty 的服务端都需要这个方法，于是我对项目做了一点重构，使用了一个抽象类 AbstractRpcServer 实现了 RpcServer 接口，而 NettyServer 和 SocketServer 继承自 AbstractRpcServer，将 scanServices 方法放在抽象类中，而 start 方法则由具体实现类来实现。\nscanServices 方法如下：\npublic void scanServices() &#123;    String mainClassName = ReflectUtil.getStackTrace();    Class&lt;?&gt; startClass;    try &#123;        startClass = Class.forName(mainClassName);        if(!startClass.isAnnotationPresent(ServiceScan.class)) &#123;            logger.error(&quot;启动类缺少 @ServiceScan 注解&quot;);            throw new RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);        &#125;    &#125; catch (ClassNotFoundException e) &#123;        logger.error(&quot;出现未知错误&quot;);        throw new RpcException(RpcError.UNKNOWN_ERROR);    &#125;    String basePackage = startClass.getAnnotation(ServiceScan.class).value();    if(&quot;&quot;.equals(basePackage)) &#123;        basePackage = mainClassName.substring(0, mainClassName.lastIndexOf(&quot;.&quot;));    &#125;    Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);    for(Class&lt;?&gt; clazz : classSet) &#123;        if(clazz.isAnnotationPresent(Service.class)) &#123;            String serviceName = clazz.getAnnotation(Service.class).name();            Object obj;            try &#123;                obj = clazz.newInstance();            &#125; catch (InstantiationException | IllegalAccessException e) &#123;                logger.error(&quot;创建 &quot; + clazz + &quot; 时有错误发生&quot;);                continue;            &#125;            if(&quot;&quot;.equals(serviceName)) &#123;                Class&lt;?&gt;[] interfaces = clazz.getInterfaces();                for (Class&lt;?&gt; oneInterface: interfaces)&#123;                    publishService(obj, oneInterface.getCanonicalName());                &#125;            &#125; else &#123;                publishService(obj, serviceName);            &#125;        &#125;    &#125;&#125;\n\n我们首先需要获得要扫描的包的范围，就需要获取到 ServiceScan 注解的值，而我们前面说过，这个注解是加在启动类上的，那么，我们怎么知道启动类是哪一个呢？答案是通过调用栈。方法的调用和返回是通过方法调用栈来实现的，当调用一个方法时，该方法入栈，该方法返回时，该方法出站，控制回到栈顶的方法。那么，main 方法一定位于调用栈的最底端，在 ReflectUtils 中，我写了一个 getStackTrace 方法（名字起得不好），用于获取 main 所在的类。通过 Class 对象的 isAnnotationPresent 方法来判断该类是否有 ServiceScan 注解。如果有，通过startClass.getAnnotation(ServiceScan.class).value(); 获取注解的值。\n当获得扫描的范围后，就可以通过ReflectUtil.getClasses(basePackage) 获取到所有的 Class 了，逐个判断是否有 Service 注解，如果有的话，通过反射创建该对象，并且调用 publishService 注册即可。\n7.4、开启自动注册并测试以 NettyServer 为例，在 NettyServer 的构造方法最后，调用 scanServices 方法，即可自动注册所有服务：\npublic NettyServer(String host, int port, Integer serializer) &#123;      this.host = host;      this.port = port;      serviceRegistry = new NacosServiceRegistry();      serviceProvider = new ServiceProviderImpl();      this.serializer = CommonSerializer.getByCode(serializer);      scanServices();  &#125;\n\n不要忘了在 HelloServiceImpl 类上加上 @service 注解：\n@Servicepublic class HelloServiceImpl implements HelloService &#123;    @Override    public String hello(String name) &#123;        return &quot;Hello, &quot; + name;    &#125;&#125;\n\n并且在服务器启动类上加上注解：\n@ServiceScanpublic class NettyTestServer &#123;    public static void main(String[] args) &#123;        NettyServer server = new NettyServer(&quot;127.0.0.1&quot;, 9999, CommonSerializer.PROTOBUF_SERIALIZER);        server.start();    &#125;&#125;\n\n直接使用启动类所在的包作为扫描根包。\n启动类变得无比简洁！启动后应该能看到和之前相同的结果。\n","categories":["Spring Cloud"]},{"title":"Nacos使用笔记","url":"/2023/10/04/Nacos%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","content":"\n\n微服务部署下使用Nacos集成服务注册和发现，配置管理。\n\n\n1、Spring Cloud整合Nacos注册中心1.1、引入Nacos服务发现组件&lt;!-- nacos discovery 服务发现组件--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\n1.2、下载Nacos Server并启动\n下载Nacos Server 压缩包\n\nhttps://github.com/alibaba/nacos/releases\n\n启动 Server\n\n进入解压后文件夹或编译打包好的文件夹，找到如下相对文件夹 nacos&#x2F;bin，并对照操作系统实际情况之下如下命令，-m standalone表示单机模式启动。\n# Linux/Unix/Mac 操作系统，执行命令 sh startup.sh -m standalone# Windows 操作系统，执行命令 startup.cmd -m standalone\n\n1.3、配置Nacos server地址和微服务名称\n为每个微服务都配置Nacos Server 地址\n\n在每个微服务应用的 &#x2F;src&#x2F;main&#x2F;resources&#x2F;application.yml配置文件中配置 Nacos Server 地址。\nspring:   cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848   application:     name: passjava-question\n\n1.4、添加注解为每个服务使用 @EnableDiscoveryClient 注解开启服务注册与发现功能。\n@EnableDiscoveryClient@MapperScan(&quot;com.jun.passjava.question.dao&quot;)@SpringBootApplicationpublic class PassjavaQuestionApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PassjavaQuestionApplication.class, args);    &#125;&#125;\n\n1.5、访问Nacos Server后台登录后台\nhttp://localhost:8848/nacos/index.html#/login\n用户名：nacos\n密码：nacos\n2、Spring Cloud整合Nacos配置中心2.1、传统配置方式\napplication.properties文件中定义两个配置：\n\nmember.nickname = &quot;jun&quot;member.age = &quot;18&quot;\n\n\n\n\n示例控制器中定义私有变量nickname和age，@value代表从配置中取值\n\n@Value(&quot;$&#123;member.nickname&#125;&quot;)private  String nickname;@Value(&quot;$member.age&quot;)private  Integer age;\n\n\n\n\n示例控制器中定义方法：获取nick和age的值\n\n@RequestMapping(&quot;/test-local-config&quot;)public R testLocalConfig() &#123;    return R.ok().put(&quot;nickname&quot;, nickname).put(&quot;age&quot;, age);&#125;\n\n\n测试结果\n\n\n\n总结\n\n从配置文件中获取配置。这种方式的缺点是什么呢？如果要修改配置参数，则需要重新启动服务。如果服务很多，则需要重启所有服务，非常不方便。\n有没有什么办法不停服务修改配置而且使其生效呢？\n答案：有的，用Spring Cloud Alibaba的Nacos 组件就可以完成。\n2.2、引入Nacos config依赖&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n2.3、配置Nacos元数据\n微服务下添加 &#x2F;src&#x2F;main&#x2F;resources&#x2F;bootstrap.properties 配置文件。\n\n注意：bootstrap.properties 是系统级的，优先级高于其他配置文件， application.properties 是应用级别的，加载比较晚，其次是bootstrap.yml、application.yml，所以引入 Nacos 组件时，需要配置 bootstrap.properties\n\n配置 Nacos Config 元数据。\n\n需要配置Nacos的服务名，也就是对应Nacos管理平台的配置文件，和Nacos服务地址。\nspring.application.name=nacos-demospring.cloud.nacos.config.server-addr=127.0.0.1:8848\n\n2.4、Nacos后台新增配置Data ID: nacos-demo.properties\nGroup: DEFAULT_GROUP\n配置格式：\nuser.name=&quot;jun&quot;user.age=27\n\n\n \n2.5、开启动态刷新配置添加注解@RefreshScope开启动态刷新配置功能。\n@RequestMapping(&quot;/test-local-config&quot;)@RestController@RefreshScopepublic R testLocalConfig() &#123;    return R.ok().put(&quot;nickname&quot;, name).put(&quot;age&quot;,age);&#125;\n\n日志：\n2023-09-27 10:59:06.646  INFO 13252 --- [-127.0.0.1_8848] o.s.c.e.event.RefreshEventListener       : Refresh keys changed: [user.name]2023-09-27 10:59:06.646  INFO 13252 --- [-127.0.0.1_8848] c.a.nacos.client.config.impl.CacheData   : [fixed-127.0.0.1_8848] [notify-ok] dataId=nacos-demo.properties, group=DEFAULT_GROUP, md5=bd3c381399ca063d5ee908060b8c1afa, listener=com.alibaba.cloud.nacos.refresh.NacosContextRefresher$1@186a3635 2023-09-27 10:59:06.647  INFO 13252 --- [-127.0.0.1_8848] c.a.nacos.client.config.impl.CacheData   : [fixed-127.0.0.1_8848] [notify-listener] time cost=2133ms in ClientWorker, dataId=nacos-demo.properties, group=DEFAULT_GROUP, md5=bd3c381399ca063d5ee908060b8c1afa, listener=com.alibaba.cloud.nacos.refresh.NacosContextRefresher$1@186a3635 \n\n user.name更新了，通知了nacos-demo服务，刷新了配置。对应的配置id为nacos-demo.properties，分组为DEFAULT_GROUP。监听器为com.alibaba.cloud.nacos.refresh.NacosContextRefresher\n测试结果：\n\n2.6、更多命名空间、分组、多配置集用法。\n","categories":["Spring Cloud"]},{"title":"NodeJs&Vue安装配置教程","url":"/2023/10/03/NodeJs&Vue%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","content":"\n\nNodeJs安装、Vue安装、前端工程部署环境配置教程。\n\n\n一、安装Node.js1、下载\nNode.js官网下载\n2、安装\n一路Next，默认安装即可。\n\n\nfinish！\n安装完成后，检查一下是否安装成功。\n打开cmd，输入如下指令，输出对应版本即安装成功。\nnode -vnpm -v1\n\n\n\n二、创建全局安装和缓存目录在我们的安装目录下，创建名为node_cache和node_global的两个文件夹。\n\n打开cmd窗口，执行如下命令，将npm的全局模块目录和缓存目录配置到我们刚才创建的那两个目录。\nnpm config set prefix &quot;D:\\DevelopingEnvironment\\nodejs\\node_global&quot;npm config set cache &quot;D:\\DevelopingEnvironment\\nodejs\\node_cache&quot;\n\n为了以后下载包快速，修改源为淘宝镜像。\nnpm config set registry https://registry.npm.taobao.org\n\n查看npm配置修改是否成功\nnpm config list\n\n\n\n三、配置环境变量在安装过程中，自动配置了两个环境变量，一个是环境变量—用户变量—Path里面的C:\\Users\\你的用户名\\AppData\\Roaming\\npm，另一个是环境变量—系统变量—Path里面的软件安装目录，我们需要增加和修改一下。\n1、环境变量—用户变量—选中Path—点编辑，将C:\\Users\\你的用户名\\AppData\\Roaming\\npm修改为 你的安装目录\\node_global\n\n2、系统变量—Path添加node_global路径，和nodejs环境变量（默认安装时已加上）\n\n三、安装vue1、安装vue.js\nnpm install vue -gnpm install vue-cli -gnpm install vue-router -g\n\n其中-g是全局安装，指安装到global全局目录去，如果不加-g，模块就会安装到当前路径下的node_modules文件夹下，没有目录则自动创建。\n输入vue -V查看安装结果。\n注：管理员权限打开cmd窗口执行\n2、安装webpack模板\nnpm install webpack -g\n\n此外，在webpack 4x以上，webpack将命令相关的内容都放到了webpack-cli，所以还需要安装webpack-cli\nnpm install webpack-cli -g\n\n输入 webpack -v 查看安装结果。\n参考：\nhttps://blog.csdn.net/zhu_liu_kun/article/details/130616720\n","categories":["环境配置教程"]},{"title":"Redis核心技术与原理","url":"/2023/10/03/Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8E%9F%E7%90%86/","content":"\n\nRedis核心知识介绍。包括持久化、事务、过期策略、内存淘汰机制、主从复制、哨兵机制、集群部署、缓存和数据库一致性问题。\n\n\n1、Redis是如何执行的？一条命令的执行过程有很多细节，但大体可分为：\n\n客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端。\n服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行命令。\n命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。\n如果是集群模式的话，主节点还会将命令同步至子节点。\n\n2、Redis持久化Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。\nRedis 持久化拥有以下三种方式：\n\n快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；\n文件追加方式（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；\n混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。\n\n2.1、RDBRDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。\n持久化触发：\n1）手动触发\n手动触发持久化的操作有两个： save 和 bgsave ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。\n2）自动触发\n\nsave m n\n\nsave m n 是指在 m 秒内，如果有 n 个键发生改变，则自动触发持久化。\n\nflushall\n\nflushall 命令用于清空 Redis 数据库，在生产环境下一定慎用，当 Redis 执行了 flushall 命令之后，则会触发自动持久化，把 RDB 文件清空。 \n\n主从同步触发\n\n在 Redis 主从复制中，当从节点执行全量复制操作时，主节点会执行 bgsave 命令，并将 RDB 文件发送给从节点，该过程会自动触发 Redis 持久化。\nRDB文件恢复：\n当 Redis 服务器启动时，如果 Redis 根目录存在 RDB 文件 dump.rdb，Redis 就会自动加载 RDB 文件恢复持久化数据。 \n优点：\n\nRDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；\nRDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；\nRDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I&#x2F;O 等操作；\n与 AOF 格式的文件相比，RDB 文件可以更快的重启。\n\n缺点：\n\n因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据；\nRDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。\n\n2.2、AOFAOF（Append Only File）中文是附加到文件，顾名思义 AOF 可以把 Redis 每个键值对操作都记录到文件（appendonly.aof）中。\n注：使用 RDB 持久化有一个风险，它可能会造成最新数据丢失的风险。因为 RDB 的持久化有一定的时间间隔，在这个时间段内如果 Redis 服务意外终止（断电，系统崩溃、Redis进程死亡）的话，就会造成最新的数据全部丢失。\n持久化触发：\n1）自动触发\n\nalways：每条 Redis 操作命令都会写入磁盘，最多丢失一条数据；\neverysec：每秒钟写入一次磁盘，最多丢失一秒的数据；\nno：不设置写入磁盘的规则，根据当前操作系统来决定何时写入磁盘，Linux 默认 30s 写入一次数据至磁盘。\n\n2）手动触发\n在客户端执行 bgrewriteaof 命令就可以手动触发 AOF 持久化。\nAOF重写：\nAOF 是通过记录 Redis 的执行命令来持久化（保存）数据的，所以随着时间的流逝 AOF 文件会越来越多，这样不仅增加了服务器的存储压力，也会造成 Redis 重启速度变慢，为了解决这个问题 Redis 提供了 AOF 重写的功能。\nAOF 重写流程\nAOF 文件重写是生成一个全新的文件，并把当前数据的最少操作命令保存到新文件上，当把所有的数据都保存至新文件之后，Redis 会交换两个文件，并把最新的持久化操作命令追加到新文件上。\n数据恢复：\n正常情况下，只要开启了 AOF 持久化，并且提供了正常的 appendonly.aof 文件，在 Redis 启动时就会自定加载 AOF 文件并启动。\n持久化文件加载规则\n\n如果只开启了 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复；\n如果只开启了 RDB 持久化，Redis 启动时只会加载 RDB 文件（dump.rdb），进行数据恢复；\n如果同时开启了 RDB 和 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复。\n在 AOF 开启的情况下，即使 AOF 文件不存在，则创建一个空的 appendonly.aof 文件，并基于这个空的 appendonly.aof 文件启动。\n\n2.3、混合持久化在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。\n\n混合持久化的加载规则：\n\n3、Redis事务Redis 中的事务从开始到结束也是要经历三个阶段：\n\n开启事务\n命令入列\n执行事务&#x2F;放弃事务\n\n其中，开启事务使用 multi 命令，事务执行使用 exec 命令，放弃事务使用 discard 命令。\nRedis不支持事务回滚的原因有以下两个：\n\n认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；\n不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。\n\n这里不支持事务回滚，指的是不支持运行时错误的事务回滚。\n监控\nwatch 命令用于客户端并发情况下，为事务提供一个乐观锁（CAS，Check And Set），也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，某个监控项被修改了，那么整个事务就会终止执行。\n4、Redis过期策略常见的过期策略有以下三种：\n\n定时删除\n惰性删除\n定期删除\n\n定时删除\n在设置键值过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。\n\n优点：保证内存可以被尽快地释放。\n缺点：在 Redis 高负载的情况下或有大量过期键需要同时处理时，会造成 Redis 服务器卡顿，影响主业务执行。\n\n惰性删除\n不主动删除过期键，每次从数据库获取键值时判断是否过期，如果过期则删除键值，并返回 null。\n\n优点：因为每次访问时，才会判断过期键，所以此策略只会使用很少的系统资源。\n缺点：系统占用空间删除不及时，导致空间利用率降低，造成了一定的空间浪费。\n\n定期删除\n每隔一段时间检查一次数据库，随机删除一些过期键。\nRedis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。\n注：\n1、Redis 每次扫描并不是遍历过期字典中的所有键，而是随机抽取判断并删除过期键的形式执行的。\n2、过期键在主从模式下，从库对过期键的处理要完全依靠主库，主库删除过期键之后会发送 del 命令给所有的从库。\n5、Redis管道技术管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。\n通常情况下 Redis 是单行执行的，客户端先向服务器发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时不会有任何问题。\n但如果出现集中大批量的请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费，此时就需要管道技术来把所有的命令整合一次发给服务端，再一次响应给客户端，这样就能大大的提升了 Redis 的响应速度。\n6、内存淘汰机制早期版本的 Redis 有以下 6 种淘汰策略：\n\nnoeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；\nallkeys-lru：淘汰整个键值中最久未使用的键值；\nallkeys-random：随机淘汰任意键值;\nvolatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值；\nvolatile-random：随机淘汰设置了过期时间的任意键值；\nvolatile-ttl：优先淘汰更早过期的键值。\n\n在 Redis 4.0 版本中又新增了 2 种淘汰策略：\n\nvolatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；\nallkeys-lfu：淘汰整个键值中最少使用的键值。\n\n其中 allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。\n7、主从库怎么实现数据一致？Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。\n\n读操作：主库、从库都可以接收；\n写操作：首先到主库执行，然后，主库将写操作同步给从库。\n\n主从库如何进行第一次同步？\n1、当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。\n\n第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。\n具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。\n\nrunID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。\noffset，此时设为 -1，表示第一次复制。\n\n主库收到 psync 命令后，会用 FULLRESYNC 响应命令（全量复制）带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。\n在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。\n在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。\n最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。\n主从级联模式：“主 - 从 - 从”模式中，为了减轻主库压力，手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。建立起主从关系：\nreplicaof  所选从库的IP 6379\n\n这样一来，这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力。\n主从库之间网络断了怎么办？\n网络断了之后，主从库会采用增量复制的方式继续同步。即只会把主从库网络断连期间主库收到的命令，同步给从库。\n8、哨兵机制\n主观下线：\n哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。\n客观下线：\n为了避免单个哨兵因为自身网络状况不好，而误判主库下线的情况，引入多个哨兵，被称为哨兵集群。\n当大多数的哨兵实例，都判断主库已经“主观下线”了，主库就会被标记为“客观下线”\n如何选定新主库？\n三个规则：从库优先级、从库复制进度以及从库 ID 号。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。\n第一轮：优先级最高的从库得分高。\n第二轮：和旧主库同步程度最接近的从库得分高。\n第三轮：ID 号小的从库得分高。\n9、Redis切片集群如何保存更多数据？\n为了保存大量数据，有大内存云主机和切片集群两种方法。实际上，这两种方法分别对应着 Redis 应对数据量增多的两种方案：纵向扩展（scale up）和横向扩展（scale out）。\n\n纵向扩展：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。\n横向扩展：横向增加当前 Redis 实例的个数，\n\n\n数据和实例之间如何对应呢？\n在切片集群中，数据需要分布在不同实例上，那么，数据和实例之间如何对应呢？\n从 3.0 开始，官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群。Redis Cluster 方案中就规定了数据和实例的对应规则。\n具体来说，Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。\n那么，这些哈希槽又是如何被映射到具体的 Redis 实例上的呢？\n我们在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384&#x2F;N 个。\n当然， 我们也可以使用 cluster meet 命令手动建立实例间的连接，形成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数。\n客户端如何定位数据？\n在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。\n一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。\n那么，客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？这是因为，Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。\n客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。\n但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：\n\n在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；\n为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。\n\n情况一：当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽。\n那么，这个实例就会给客户端返回 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。\nGET hello:key(error) MOVED 13320 172.16.19.5:6379\n\n其中，MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。\n情况二：客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移。\n在这种迁移部分完成的情况下，客户端就会收到一条 ASK 报错信息，如下所示：\nGET hello:key(error) ASK 13320 172.16.19.5:6379\n\n这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。\n比较：ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。\n10、如何解决缓存和数据库的数据一致性问题？缓存和数据库不一致的问题，我们可以分成读写缓存和只读缓存两种情况进行分析。\n\n为了解决Redis缓存数据一致性问题，可以采用以下方案：\n缓存失效：在更新数据库数据时，同时使缓存失效。这种方式可以保证数据的最终一致性，但可能会导致一些短暂的数据不一致情况。\n缓存更新：在更新数据库数据时，同时更新缓存。这种方式可以保证数据的强一致性，但可能会增加系统的复杂性和负载。\n异步更新：在更新数据库数据时，采用异步方式更新缓存。这种方式可以保证系统的可用性和性能，但可能会导致一些短暂的数据不一致情况。\n最佳实践：\n合理选择缓存失效的时间：根据业务需求和系统特点，选择适当的缓存失效时间，以保证数据的及时性和一致性。\n使用分布式锁：在进行数据库和缓存的更新操作时，使用分布式锁来避免并发问题导致的数据不一致情况。\n定期同步缓存和数据库：定期进行缓存和数据库的同步操作，以保证数据的一致性。\n采用合理的缓存策略：根据业务需求和系统特点，采用合理的缓存策略，如缓存失效、缓存更新、异步更新等，以保证数据的一致性和性能。\n使用分布式事务：在进行数据库和缓存的更新操作时，使用分布式事务来保证数据的一致性和可靠性。\n监控和告警：对Redis缓存系统进行监控和告警，及时发现和解决数据一致性问题。\n————————————————\n","categories":["Redis"]},{"title":"Redis实现排行榜","url":"/2023/10/04/Redis%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C/","content":"\n\n基于Redis的基本数据结构和业务逻辑设计实现用户活跃排行榜。\n\n\n1.1、场景说明技术派中，设计了一个社区用户的活跃排行榜，包括日榜和月榜。\n用户活跃度计算方式：\n\n用户每访问一个新的页面， +1分\n对于一篇文章，点赞、收藏， +2分；取消点赞、取消收藏，将之前的活跃分收回。\n文章评论， +3分\n发布一篇审核通过的文章， +10分\n\n榜单：展示活跃度最高的前三十名用户。\n效果如下：\n\n1.2、方案设计使用Redis的ZSet数据结构实现，以下是ZSet的简介：\nRedis的ZSet（有序集合）是一种有序的、唯一的数据结构。它类似于Set，但每个元素都关联着一个分数（score），用于进行排序。\nZSet的特点包括：\n\n有序性：ZSet中的元素按照分数进行排序，可以根据分数进行范围查询、区间获取等操作。 \n唯一性：ZSet中的元素是唯一的，不会存在重复的元素。 \n快速的插入和删除：ZSet使用了跳跃表（Skip List）和哈希表（Hash Table）的结合体，使得插入和删除操作的时间复杂度为O(log N)。 \n高效的查找：通过索引和跳跃表的特性，可以在O(log N)的时间复杂度内查找某个元素。\n\nZSet常用的操作包括：\n\nZADD：向ZSet中添加一个元素，同时指定其分数。\nZREM：从ZSet中移除一个元素。\nZRANGE：按照分数的顺序，获取指定范围内的元素。\nZSCORE：获取指定元素的分数。\nZINCRBY：将指定元素的分数增加一个特定的值。\n\nZSet广泛应用于排行榜、计分系统、排行榜、时间轴等场景，提供了高效的排序和检索功能。\n1.3、排行榜实现1.3.1、业务实体设计​       我们先实现一个更新用户活跃的方法，首先定义一个涵盖该业务场景的参数传递实体 ActivityScoreBo，记录用户活动（是否访问页面、点赞、收藏、评论、关注、发布文章）。\n@Data@Accessors(chain = true)public class ActivityScoreBo &#123;    /**     * 访问页面增加活跃度     */    private String path;    /**     * 目标文章     */    private Long articleId;    /**     * 评论增加活跃度     */    private Boolean rate;    /**     * 点赞增加活跃度     */    private Boolean praise;    /**     * 收藏增加活跃度     */    private Boolean collect;    /**     * 发布文章增加活跃度     */    private Boolean publishArticle;    /**     * 被关注的用户     */    private Long followedUserId;    /**     * 关注增加活跃度     */    private Boolean follow;&#125;  \n\n\n\n有了业务实体，进一步我们需要计算活跃度。活跃度包括日榜和月榜，如下为对应的key生成。\n/**     * 当天活跃度排行榜     *     * @return 当天排行榜key     */    private String todayRankKey() &#123;        return ACTIVITY_SCORE_KEY + DateUtil.format(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;), System.currentTimeMillis());    &#125;    /**     * 本月排行榜     *     * @return 月度排行榜key     */    private String monthRankKey() &#123;        return ACTIVITY_SCORE_KEY + DateUtil.format(DateTimeFormatter.ofPattern(&quot;yyyyMM&quot;), System.currentTimeMillis());    &#125;\n\n\n\n1.3.2、计算活跃度（1）根据传入的业务实体，判断文章浏览、点赞、收藏、关注、排列、发文等行为，并计算对应的字段field和分数score，不同行为的加分机制见上述场景说明。\n（2）接着，根据用户ID和当天日期（日为单位）生成一个唯一的活跃度信息的键值（userActionKey）。\n（3）通过RedisClient从Redis中获取该userActionKey键对应的field值（ans）。\n（4）如果ans为null，说明之前没有加分记录，执行加分操作： \n\n\n如果加分数大于0，将加分记录保存到Redis的hash结构中，并设置有效期为一个月。&#x2F;注：【加分记录使用Redis的Hash结构存储，key为userActionKey，字段为field，value为分数score】\n更新当天和当月的活跃度排行榜，使用Redis的zIncrBy函数。\n如果新的活跃度得分大于等于加分数，更新日活跃榜单和月活跃榜单的有效期。\n\n\n\n（5）如果ans大于0，说明之前该field已经加过分，继续判断： \n\n\n如果分数小于0，说明是减分行为，应从Redis中删除加分记录。\n更新当天和当月的活跃度排行榜。\n\n\n\n幂等策略：\n在上述加分操作中，为了防止重复加活跃度，我们做了一个幂等操作。\n就是将用户的每个加分项，都记录下来，在执行具体加分时，基于此来做幂等判定 。\n因此，我们对每个用户维护一个活跃更新的操作历史记录表，保存在redis的hash数据结构中，每天一个记录。\nkey: activity_rank_&#123;user_id&#125;_&#123;年月日&#125; field: 活跃度更新keyvalue: 添加的活跃度  \n\n\n\n思考：\n1、事务问题：虽然单个redis操作是原子性的，但多次的redis操作，存在事务问题。\n2、并发问题：没有做并发，幂等无法100%生效，依然可能存在重复添加&#x2F;扣减活跃度的情况  \n问题一：\n通过最终一致性（Eventual Consistency）来解决多次Redis操作的事务问题是一种常见的方法。最终一致性是指在分布式系统中，经过一段时间后，系统的所有副本最终会达到一致的状态。\n在Redis中，可以使用以下方法来实现最终一致性：\n\n批量操作：将多个操作组合成一个批量操作，减少网络往返的次数。例如，使用管道（Pipeline）来发送多个命令，然后一次性获取它们的响应。 \n异步操作：将操作异步化，即将操作放入消息队列或任务队列中，由后台线程或其他服务异步处理。这样可以避免阻塞主线程，并允许操作在不同的时间点执行。 \n回滚机制：在执行操作之前，先将相关数据备份或记录下来。如果操作失败，可以使用备份数据进行回滚操作。 \n重试机制：如果某个操作失败，可以进行重试，直到操作成功或达到最大重试次数。 \n业务层面的补偿机制：如果操作失败，可以通过业务逻辑来进行补偿操作，以达到一致性。\n\n需要注意的是，最终一致性并不能提供强一致性的保证，因此在某些场景下可能会出现数据不一致的情况。在选择使用最终一致性来解决事务问题时，需要根据具体的业务需求和数据一致性要求来评估和权衡。\n问题二：\n通过加锁解决并发问题。\npublic void addActivityScore(Long userId, ActivityScoreBo activityScore) &#123;        if (userId == null) &#123;            return;        &#125;        // 1. 计算活跃度(正为加活跃,负为减活跃)        String field;        int score = 0;        if (activityScore.getPath() != null) &#123;            field = &quot;path_&quot; + activityScore.getPath();            score = 1;        &#125; else if (activityScore.getArticleId() != null) &#123;            field = activityScore.getArticleId() + &quot;_&quot;;            if (activityScore.getPraise() != null) &#123;                field += &quot;praise&quot;;                score = BooleanUtils.isTrue(activityScore.getPraise()) ? 2 : -2;            &#125; else if (activityScore.getCollect() != null) &#123;                field += &quot;collect&quot;;                score = BooleanUtils.isTrue(activityScore.getCollect()) ? 2 : -2;            &#125; else if (activityScore.getRate() != null) &#123;                // 评论回复                field += &quot;rate&quot;;                score = BooleanUtils.isTrue(activityScore.getRate()) ? 3 : -3;            &#125; else if (BooleanUtils.isTrue(activityScore.getPublishArticle())) &#123;                // 发布文章                field += &quot;publish&quot;;                score += 10;            &#125;        &#125; else if (activityScore.getFollowedUserId() != null) &#123;            field = activityScore.getFollowedUserId() + &quot;_follow&quot;;            score = BooleanUtils.isTrue(activityScore.getFollow()) ? 2 : -2;        &#125; else &#123;            return;        &#125;        final String todayRankKey = todayRankKey();        final String monthRankKey = monthRankKey();        // 2. 幂等：判断之前是否有更新过相关的活跃度信息        final String userActionKey = ACTIVITY_SCORE_KEY + userId + DateUtil.format(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;), System.currentTimeMillis());        Integer ans = RedisClient.hGet(userActionKey, field, Integer.class);        if (ans == null) &#123;            // 2.1 之前没有加分记录，执行具体的加分            if (score &gt; 0) &#123;                // 记录加分记录                RedisClient.hSet(userActionKey, field, score);                // 个人用户的操作记录，保存一个月的有效期，方便用户查询自己最近31天的活跃情况                RedisClient.expire(userActionKey, 31 * DateUtil.ONE_DAY_SECONDS);                // 更新当天和当月的活跃度排行榜                Double newAns = RedisClient.zIncrBy(todayRankKey, String.valueOf(userId), score);                RedisClient.zIncrBy(monthRankKey, String.valueOf(userId), score);                if (log.isDebugEnabled()) &#123;                    log.info(&quot;活跃度更新加分! key#field = &#123;&#125;#&#123;&#125;, add = &#123;&#125;, newScore = &#123;&#125;&quot;, todayRankKey, userId, score, newAns);                &#125;                if (newAns &lt;= score) &#123;                    // 日活跃榜单，保存31天；月活跃榜单，保存1年                    RedisClient.expire(todayRankKey, 31 * DateUtil.ONE_DAY_SECONDS);                    RedisClient.expire(monthRankKey, 12 * DateUtil.ONE_MONTH_SECONDS);                &#125;            &#125;        &#125; else if (ans &gt; 0) &#123;            // 2.2 之前已经加过分，因此这次减分可以执行            if (score &lt; 0) &#123;                Boolean oldHave = RedisClient.hDel(userActionKey, field);                if (BooleanUtils.isTrue(oldHave)) &#123;                    Double newAns = RedisClient.zIncrBy(todayRankKey, String.valueOf(userId), score);                    RedisClient.zIncrBy(monthRankKey, String.valueOf(userId), score);                    if (log.isDebugEnabled()) &#123;                        log.info(&quot;活跃度更新减分! key#field = &#123;&#125;#&#123;&#125;, add = &#123;&#125;, newScore = &#123;&#125;&quot;, todayRankKey, userId, score, newAns);                    &#125;                &#125;            &#125;        &#125;    &#125;\n\n\n\n1.3.3、触发活跃度更新前面只是提供了一个增加活跃度的方法，但是什么时候调用它呢？\n我们这里借助之前实现 Event&#x2F;Listenter方式来处理活跃度更新。\n文章&#x2F;用户的相关操作事件监听，并更新对应的活跃度：\npublic class UserActivityListener &#123;    @Autowired    private UserActivityRankService userActivityRankService;    /**     * 用户操作行为，增加对应的积分     *     * @param msgEvent     */    @EventListener(classes = NotifyMsgEvent.class)    @Async    public void notifyMsgListener(NotifyMsgEvent msgEvent) &#123;        switch (msgEvent.getNotifyType()) &#123;            case COMMENT:            case REPLY:                CommentDO comment = (CommentDO) msgEvent.getContent();                userActivityRankService.addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo()                        .setRate(true).setArticleId(comment.getArticleId()));                break;            case COLLECT:                UserFootDO foot = (UserFootDO) msgEvent.getContent();                userActivityRankService.addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo().setCollect(true).setArticleId(foot.getDocumentId()));                break;            case CANCEL_COLLECT:                foot = (UserFootDO) msgEvent.getContent();                userActivityRankService.addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo().setCollect(false).setArticleId(foot.getDocumentId()));                break;            case PRAISE:                foot = (UserFootDO) msgEvent.getContent();                userActivityRankService.addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo().setPraise(true).setArticleId(foot.getDocumentId()));                break;            case CANCEL_PRAISE:                foot = (UserFootDO) msgEvent.getContent();                userActivityRankService.addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo().setPraise(false).setArticleId(foot.getDocumentId()));                break;            case FOLLOW:                UserRelationDO relation = (UserRelationDO) msgEvent.getContent();                userActivityRankService.addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo().setFollow(true).setArticleId(relation.getUserId()));                break;            case CANCEL_FOLLOW:                relation = (UserRelationDO) msgEvent.getContent();                userActivityRankService.addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo().setFollow(false).setArticleId(relation.getUserId()));                break;            default:        &#125;    &#125;    /**     * 发布文章，更新对应的积分     *     * @param event     */    @Async    @EventListener(ArticleMsgEvent.class)    public void publishArticleListener(ArticleMsgEvent&lt;ArticleDO&gt; event) &#123;        ArticleEventEnum type = event.getType();        if (type == ArticleEventEnum.ONLINE) &#123;            userActivityRankService.addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo().setPublishArticle(true).setArticleId(event.getContent().getId()));        &#125;    &#125;&#125;\n\n\n\n接下来，就是对应方法触发后事件更新了，包括ArticleMsgEvent、NotifyMsgEvent等。\n\n另外，针对用户浏览页面的活跃度触发，我们在 Filte&#x2F;Inteceptor 层实现，通过GlobalViewInterceptor的preHandle方法实现。\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        if (handler instanceof HandlerMethod) &#123;            HandlerMethod handlerMethod = (HandlerMethod) handler;            Permission permission = handlerMethod.getMethod().getAnnotation(Permission.class);            if (permission == null) &#123;                permission = handlerMethod.getBeanType().getAnnotation(Permission.class);            &#125;            if (permission == null || permission.role() == UserRole.ALL) &#123;                if (ReqInfoContext.getReqInfo() != null) &#123;                    // 用户活跃度更新                    SpringUtil.getBean(UserActivityRankService.class).addActivityScore(ReqInfoContext.getReqInfo().getUserId(), new ActivityScoreBo().setPath(ReqInfoContext.getReqInfo().getPath()));                &#125;                return true;            &#125;        &#125;        return true;    &#125;\n\n\n\n1.3.4、排行榜查询接下来就是将这个榜单展示给用户看。\n基本流程如下： \n1、从redis中获取topN的用户+评分 \n2、查询用户的信息 \n3、根据用户评分进行排序，并更新每个用户的排名\npublic List&lt;RankItemDTO&gt; queryRankList(ActivityRankTimeEnum time, int size) &#123;        String rankKey = time == ActivityRankTimeEnum.DAY ? todayRankKey() : monthRankKey();        // 1. 获取topN的活跃用户        List&lt;ImmutablePair&lt;String, Double&gt;&gt; rankList = RedisClient.zTopNScore(rankKey, size);        if (CollectionUtils.isEmpty(rankList)) &#123;            return Collections.emptyList();        &#125;        // 2. 查询用户对应的基本信息        // 构建userId -&gt; 活跃评分的map映射，用于补齐用户信息        Map&lt;Long, Integer&gt; userScoreMap = rankList.stream().collect(Collectors.toMap(s -&gt; Long.valueOf(s.getLeft()), s -&gt; s.getRight().intValue()));        List&lt;SimpleUserInfoDTO&gt; users = userService.batchQuerySimpleUserInfo(userScoreMap.keySet());        // 3. 根据评分进行排序        List&lt;RankItemDTO&gt; rank = users.stream()                .map(user -&gt; new RankItemDTO().setUser(user).setScore(userScoreMap.getOrDefault(user.getUserId(), 0)))                .sorted((o1, o2) -&gt; Integer.compare(o2.getScore(), o1.getScore()))                .collect(Collectors.toList());        // 4. 补齐每个用户的排名        IntStream.range(0, rank.size()).forEach(i -&gt; rank.get(i).setRank(i + 1));        return rank;    &#125;\n\n其中核心方法是Redis的zRangeWithScores，用以获取指定排名的用户和对应分数。\nzrevrange 是Redis中的一个有序集合操作命令，用于按照分数从大到小的顺序获取有序集合中指定范围内的成员。\n命令语法如下：ZREVRANGE key start stop [WITHSCORES]参数说明：\n\nkey ：有序集合的键名。\nstart ：指定范围的起始位置，从0开始计数，表示成员的排名。\nstop ：指定范围的结束位置，从0开始计数，表示成员的排名。\nWITHSCORES （可选）：如果提供了该参数，命令会返回成员和对应的分数，以一个成员和一个分数交替排列的方式返回结果。\n\n\n示例：假设有一个有序集合名为 myset ，包含以下成员和对应的分数：“member1” -&gt; 10“member2” -&gt; 20“member3” -&gt; 30“member4” -&gt; 40“member5” -&gt; 50使用 ZREVRANGE myset 0 2 命令，将返回范围为0到2的成员：\n\n“member5”\n“member4”\n“member3”使用 ZREVRANGE myset 0 2 WITHSCORES 命令，将返回范围为0到2的成员和对应的分数：\n“member5”\n“50”\n“member4”\n“40”\n“member3”\n“30”\n\n\npublic static List&lt;ImmutablePair&lt;String, Double&gt;&gt; zTopNScore(String key, int n) &#123;        return template.execute(new RedisCallback&lt;List&lt;ImmutablePair&lt;String, Double&gt;&gt;&gt;() &#123;            @Override            public List&lt;ImmutablePair&lt;String, Double&gt;&gt; doInRedis(RedisConnection connection) throws DataAccessException &#123;                Set&lt;RedisZSetCommands.Tuple&gt; set = connection.zRangeWithScores(keyBytes(key), -n, -1);                if (set == null) &#123;                    return Collections.emptyList();                &#125;                return set.stream()                        .map(tuple -&gt; ImmutablePair.of(toObj(tuple.getValue(), String.class), tuple.getScore()))                        .sorted((o1, o2) -&gt; Double.compare(o2.getRight(), o1.getRight())).collect(Collectors.toList());            &#125;        &#125;);    &#125;","categories":["项目实战"]},{"title":"Swagger接口文档使用","url":"/2023/10/04/Swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8/","content":"\n\nSpring Boot集成Swagger显示后端服务方法RestFul接口文档、方便功能测试和前端联调。\n\n\n1、Swagger简介\n前后端分离\n\n前端 -&gt; 前端控制层、视图层\n\n后端 -&gt; 后端控制层、服务层、数据访问层\n\n前后端通过API进行交互\n\n前后端相对独立且松耦合\n\n\n产生的问题\n\n前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发。\n\n解决方案\n首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险。\nSwagger\n\n号称世界上最流行的API框架\nRestful Api 文档在线自动生成器 &#x3D;&gt; API 文档 与API 定义同步更新\n直接运行，在线测试API\n支持多种语言 （如：Java，PHP等）\n官网：https://swagger.io/\n\n2、SpringBoot集成Swagger\nSpringBoot集成Swagger &#x3D;&gt; springfox，两个jar包\n\nSpringfox-swagger2\nswagger-springmvc\n\n要求：jdk 1.8 + 否则swagger2无法运行\n步骤：\n1、新建一个SpringBoot-web项目\n2、添加Maven依赖\n&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;\n\n注：swagger2.9.2版本需要在spring boot2.6之前的版本才能完美运行。\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.5.7&lt;/version&gt;\n\n\n\n3、编写HelloController，测试确保运行成功！\n4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger\n@Configuration //配置类@EnableSwagger2// 开启Swagger2的自动配置public class SwaggerConfig &#123;  &#125;\n\n5、访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面；\n\n3、配置Swagger\n3.1、初步集成1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。\n在SwaggerConfig类中添加如下代码：\n@Bean //配置docket以配置Swagger具体参数public Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2);&#125;\n\n2、可以通过apiInfo()属性配置文档信息\n//配置文档信息private ApiInfo apiInfo() &#123;   Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);   return new ApiInfo(           &quot;Swagger学习&quot;, // 标题           &quot;学习演示如何配置Swagger&quot;, // 描述           &quot;v1.0&quot;, // 版本           &quot;http://terms.service.url/组织链接&quot;, // 组织链接           contact, // 联系人信息           &quot;Apach 2.0 许可&quot;, // 许可           &quot;许可链接&quot;, // 许可连接           new ArrayList&lt;&gt;()// 扩展  );&#125;\n\n3、Docket 实例关联上 apiInfo()\n@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());&#125;\n\n4、重启项目，访问测试 http://localhost:8080/swagger-ui.html  看下效果；\n\n3.2、配置扫描接口1、构建Docket时通过select()方法配置怎么扫描接口。\n@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口      .apis(RequestHandlerSelectors.basePackage(&quot;com.example.swaggertest.controller&quot;))      .build();&#125;\n\n2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类\n\n3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口：\nany() // 扫描所有，项目中的所有接口都会被扫描到none() // 不扫描接口// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)basePackage(final String basePackage) // 根据包路径扫描接口\n\n4、除此之外，我们还可以配置接口扫描过滤：\n@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))      .build();&#125;\n\n5、这里的可选值还有\nany() // 任何请求都扫描none() // 任何请求都不扫描regex(final String pathRegex) // 通过正则表达式控制ant(final String antPattern) // 通过ant()控制\n\n\n3.3、配置Swagger开关1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了\n@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))      .build();&#125;\n\n2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？\n@Beanpublic Docket docket(Environment environment) &#123;   // 设置要显示swagger的环境   Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);   // 判断当前是否处于该环境   // 通过 enable() 接收此参数判断是否要显示   boolean b = environment.acceptsProfiles(of);      return new Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))       // 配置如何通过path过滤,即这里只扫描请求以/jun开头的接口      .paths(PathSelectors.ant(&quot;/jun/**&quot;))      .build();&#125;\n\n3、可以在项目中增加一个dev的配置文件查看效果！\n\n3.4、配置API分组\n1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：\n@Beanpublic Docket docket(Environment environment) &#123;   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())      .groupName(&quot;hello&quot;) // 配置分组       // 省略配置....&#125;\n\n2、重启项目查看分组\n3、如何配置多个分组？配置多个分组只需要配置多个docket即可：\n@Beanpublic Docket docket1()&#123;   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);&#125;@Beanpublic Docket docket2()&#123;   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);&#125;@Beanpublic Docket docket3()&#123;   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);&#125;\n\n4、重启项目查看即可\n3.5、实体配置1、新建一个实体类\n@ApiModel(&quot;用户实体&quot;)public class User &#123;   @ApiModelProperty(&quot;用户名&quot;)   public String username;   @ApiModelProperty(&quot;密码&quot;)   public String password;&#125;\n\n2、只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中：\n@RequestMapping(&quot;/getUser&quot;)public User getUser()&#123;   return new User();&#125;\n\n3、重启查看测试\n\n注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。\n@ApiModel为类添加注释\n@ApiModelProperty为类属性添加注释\n3.6、常用注解Swagger的所有注解定义在io.swagger.annotations包下\n下面列一些经常用到的，未列举出来的可以另行查阅说明：\n\n\n\nSwagger注解\n简单说明\n\n\n\n@Api(tags &#x3D; “xxx模块说明”)\n作用在模块类上\n\n\n@ApiOperation(“xxx接口说明”)\n作用在接口方法上\n\n\n@ApiModel(“xxxPOJO说明”)\n作用在模型类上：如VO、BO\n\n\n@ApiModelProperty(value &#x3D; “xxx属性说明”,hidden &#x3D; true)\n作用在类方法和属性上，hidden设置为true可以隐藏该属性\n\n\n@ApiParam(“xxx参数说明”)\n作用在参数、方法和字段上，类似@ApiModelProperty\n\n\n我们也可以给请求的接口配置一些注释\n@ApiOperation(&quot;xxx的接口&quot;)@PostMapping(&quot;/jun&quot;)@ResponseBodypublic String test(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;   return username;&#125;\n\n这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！\n相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。\nSwagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。\n3.7、拓展：其他皮肤我们可以导入不同的包实现不同的皮肤定义：\n1、默认的   访问 http://localhost:8080/swagger-ui.html\n&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n2、bootstrap-ui  访问 http://localhost:8080/doc.html\n&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;   &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;   &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;\n\n\n3、Layui-ui   访问 http://localhost:8080/docs.html\n&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;   &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;   &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt;\n\n\n4、mg-ui   访问 http://localhost:8080/document.html\n&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;&lt;dependency&gt;   &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;   &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;   &lt;version&gt;1.0.6&lt;/version&gt;&lt;/dependency&gt;","categories":["Spring Boot"]},{"title":"古人词抄","url":"/2020/04/07/%E5%8F%A4%E4%BA%BA%E8%AF%8D%E6%8A%84/","content":"此卷系作者读书所录文字思想，于时光悠悠处，细看白鸟绕南山，小池澹澹碧。\n \n\n第一辑  漱玉词漱玉之名，源于李清照僦居济南处庭前漱玉泉，泉水清冽，至今汩汩。\n渔家傲  天接云涛连晓雾天接云涛连晓雾。星河欲转千帆舞。仿佛梦魂归帝所。闻天语。殷勤问我归何处。\n我报路长嗟日暮。学诗谩有惊人句。九万里风鹏正举。风休住。蓬舟吹取三山去。\n渔家傲 雪里已知春信至雪里已知春信至。寒梅点缀琼枝腻。香脸半开娇旖旎。当庭际。玉人浴出新妆洗。\n造化可能偏有意。故教明月玲珑地。共赏金尊沈绿蚁。莫辞醉。此花不与群花比。\n如梦令 常记溪亭日暮（一题作酒兴）\n常记溪亭日暮，沉醉不知归路。兴尽晚回舟，误入藕花深处。争渡，争渡，惊起一滩鸥鹭。\n如梦令 昨夜雨疏风骤（一题作春晚）\n昨夜雨疏风骤，浓睡不消残酒。试问卷帘人，却道海棠依旧。知否？知否？应是绿肥红瘦。\n如梦令  谁伴明窗独坐谁伴明窗独坐，我共影儿俩个。灯尽欲眠时，影也把人抛躲。无那，无那，好个凄凉的我。\n浣溪沙 绣面芙蓉一笑开绣面芙蓉一笑开。斜飞宝鸭衬香腮。眼波才动被人猜。\n一面风情深有韵，半笺娇恨寄幽怀。月移花影约重来。\n浣溪沙 髻子伤春慵更梳髻子伤春慵更梳。晚风庭院落梅初。淡云来往月疏疏。\n玉鸭熏炉闲瑞脑，朱樱斗帐掩流苏。通犀还解辟寒无。\n一剪梅 红藕香残玉簟秋红藕香残玉簟秋。轻解罗裳，独上兰舟。云中谁寄锦书来，雁字回时，月满西楼。花自飘零水自流。一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。\n蝶恋花  泪湿罗衣脂粉满泪湿罗衣脂粉满，四叠阳关，唱到千千遍。人道山长山又断，萧萧微雨闻孤馆。惜别伤离方寸乱，忘了临行，酒盏深和浅。好把音书凭过雁，东莱不似蓬莱远。\n鹧鸪天  暗淡轻黄体性柔暗淡轻黄体性柔，情疏迹远只香留。 何须浅碧轻红色，自是花中第一流。\n梅定妒，菊应羞，画栏开处冠中秋。 骚人可煞无情思，何事当年不见收。\n临江仙 庭院深深深几许欧阳公作《蝶恋花》，有“深深深几许”之句，予酷爱之。用其语作“庭院深深”数阕，其声即旧《临江仙》也。\n庭院深深深几许？云窗雾阁常扃。柳梢梅萼渐分明。春归秣陵树，人老建康城。感月吟风多少事，如今老去无成。谁怜憔悴更凋零。试灯无意思，踏雪没心情。\n醉花阴 薄雾浓云愁永昼薄雾浓云愁永昼，瑞脑消金兽。佳节又重阳，玉枕纱橱，半夜凉初透。\n东篱把酒黄昏后，有暗香盈袖。莫道不销魂，帘卷西风，人比黄花瘦。\n武陵春  风住尘香花已尽风住尘香花已尽，日晚倦梳头。物是人非事事休，欲语泪先流。\n 闻说双溪春尚好，也拟泛轻舟，只恐双溪舴艋舟，载不动许多愁。\n声声慢  寻寻觅觅寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急？雁过也，正伤心，却是旧时相识。\n满地黄花堆积。憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑？梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！\n清平乐  年年雪里年年雪里。常插梅花醉。挼尽梅花无好意。赢得满衣清泪。\n今年海角天涯。萧萧两鬓生华。看取晚来风势，故应难看梅花。\n点绛唇  蹴罢秋千蹴罢秋千，起来慵整纤纤手。露浓花瘦，薄汗轻衣透。\n  见客入来，袜刬金钗溜。和羞走，倚门回首，却把青梅嗅。\n点绛唇  寂寞深闺寂寞深闺，柔肠一寸愁千缕。惜春春去。几点催花雨。\n  倚遍阑干，只是无情绪。人何处。连天衰草，望断归来路。\n满庭芳  小阁藏春小阁藏春，闲窗锁昼，画堂无限深幽。篆香烧尽，日影下帘钩。手种江梅渐好，又何必、临水登楼。无人到，寂寥浑似，何逊在扬州。\n从来，知韵胜，难堪雨藉，不耐风揉。更谁家横笛，吹动浓愁。莫恨香消雪减，须信道、扫迹情留。难言处，良宵淡月，疏影尚风流。\n御街行  藤床纸帐朝眠起藤床纸帐朝眠起。说不尽、无佳思。沈香断续玉炉寒，伴我情怀如水。笛里三弄，梅心惊破，多少春情意。\n小风疏雨萧萧地。又催下、千行泪。吹箫人去玉楼空，肠断与谁同倚。一枝折得，人间天上，没个人堪寄。\n玉楼春  红酥肯放琼苞碎红酥肯放琼苞碎，探著南枝开遍未。不知酝藉几多香，但见包藏无限意。\n道人憔悴春窗底，闷损阑干愁不倚。要来小酌便来休，未必明朝风不起。\n永遇乐 落日熔金落日熔金，暮云合壁，人在何处。染柳烟浓，吹梅笛怨，春意知几许。元宵佳节，融和天气，次第岂无风雨。来相召、香车宝马，谢他酒朋诗侣。\n中州盛日，闺门多暇，记得偏重三五。铺翠冠儿，捻金雪柳，簇带争济楚。如今憔悴，风鬟霜鬓，怕见夜间出去。不如向、帘儿底下，听人笑语。\n青玉案  一年春事都来几一年春事都来几。早过了、三之二。绿暗红嫣浑可事。绿杨庭院，暖风帘幕，有个人憔悴。\n买花载酒长安市。又争似家山见桃李。不枉东风吹客泪，相思难表，梦魂无据，惟有归来是。\n添字丑奴儿 窗前谁种芭蕉树窗前谁种芭蕉树，阴满中庭。阴满中庭。叶叶心心，舒卷有馀清。\n伤心枕上三更雨，点滴霖霪。点滴霖霪。愁损北人，不惯起来听。\n摊破浣溪沙  病起萧萧两鬓华病起萧萧两鬓华。卧看残月上窗纱。豆蔻连梢煎熟水，莫分茶。\n枕上诗书闲处好，门前风景雨来佳。终日向人多藉藉，木犀花。\n摊破浣溪沙  揉破黄金万点轻揉破黄金万点轻，剪成碧玉叶层层。风度精神如彦辅，太鲜明。\n梅蕊重重何俗甚，丁香千结苦粗生。熏透愁人千里梦，却无情。\n第二辑  小山词黄庭坚曰：淮海、小山，真古之伤心人也。余读其词，深情娟丽，真谓痴也。\n临江仙  梦后楼台高锁梦后楼台高锁，酒醒帘幕低垂。去年春恨却来时。落花人独立，微雨燕双飞。\n记得小苹初见，两重心字罗衣。琵琶弦上说相思。当时明月在，曾照彩云归。\n鹧鸪天  彩袖殷勤捧玉钟彩袖殷勤捧玉钟。当年拚却醉颜红。舞低杨柳楼心月，歌尽桃花扇影风。\n从别后，忆相逢。几回魂梦与君同。今宵剩把银红照，犹恐相逢是梦中。\n生查子 关山魂梦长关山魂梦长，鱼雁音尘少。两鬓可怜青，只为相思老。\n归梦碧纱窗，说与人人道。真个别离难，不似相逢好。\n清平乐 留人不住留人不住。醉解兰舟去。一棹碧涛春水路。过尽晓莺啼处。\n渡头杨柳青青。枝枝叶叶离情。此后锦书休寄，画楼云雨无凭。\n木兰花 初心已恨花期远初心已恨花期晚。别后相思长在眼。兰衾犹有旧时香，每到梦回珠泪满。\n多应不信人肠断。几夜夜寒谁共暖。欲将恩爱结来生，只恐来生缘又短。\n思远人 红叶黄花秋意晚红叶黄花秋意晚，千里念行客。飞云过尽，归鸿无信，何处寄书得。\n泪弹不尽临窗滴。就砚旋研墨。渐写到别来，此情深处，红笺为无色。\n长相思 长相思长相思。长相思。若问相思甚了期。除非相见时。\n长相思。长相思。欲把相思说似谁。浅情人不知。\n第三辑  范仲淹词笔苏幕遮  怀旧碧云天，黄叶地，秋色连波，波上寒烟翠。山映斜阳天接水，芳草无情，更在斜阳外。\n黯乡魂，追旅思，夜夜除非，好梦留人睡。明月楼高休独倚，酒入愁肠，化作相思泪。\n渔家傲 秋思塞下秋来风景异，衡阳雁去无留意。四面边声连角起。千嶂里，长烟落日孤城闭。\n浊酒一杯家万里，燕然未勒归无计。羌管悠悠霜满地。人不寐，将军白发征夫泪。\n御街行 秋日怀旧纷纷坠叶飘香砌，夜寂静，寒声碎。真珠帘卷玉楼空，天淡银河垂地。年年今夜，月华如练，长是人千里。\n愁肠已断无由醉，酒未到，先成泪。残灯明灭枕头敧，谙尽孤眠滋味。都来此事，眉间心上，无计相回避。\n第四辑  欧阳修词笔踏莎行 候馆梅残候馆梅残，溪桥柳细。草薰风暖摇征辔。离愁渐远渐无穷，迢迢不断如春水。\n寸寸柔肠，盈盈粉泪。楼高莫近危阑倚。平芜尽处是春山，行人更在春山外。\n玉楼春 尊前拟把归期说尊前拟把归期说。未语春容先惨咽。人生自是有情痴，此恨不关风与月。\n离歌且莫翻新阕。一曲能教肠寸结。直须看尽洛城花，始共春风容易别。\n玉楼春 别后不知君远近别后不知君远近。触目凄凉多少闷。渐行渐远渐无书，水阔鱼沈何处问。\n夜深风竹敲秋韵。万叶千声皆是恨。故欹单枕梦中寻，梦又不成灯又烬。\n南歌子 凤髻金泥带凤髻金泥带，龙纹玉掌梳。走来窗下笑相扶。爱道画眉深浅入时无。\n弄笔偎人久，描花试手初。等闲妨了绣功夫。笑问鸳鸯二字怎生书。\n临江仙 记得金銮同唱第记得金銮同唱第，春风上国繁华。如今薄宦老天涯。十年岐路，空负曲江花。\n闻说阆山通阆苑，楼高不见君家。孤城寒日等闲斜。离愁难尽，红树远连霞。\n浪淘沙 把酒祝东风把酒祝东风。且共从容。垂杨紫陌洛城东。总是当时携手处，游遍芳丛。\n聚散苦匆匆。此恨无穷。今年花胜去年红。可惜明年花更好，知与谁同。\n浣溪沙 堤上游人逐画船堤上游人逐画船。拍堤春水四垂天。绿杨楼外出秋千。\n白发戴花君莫笑，六么催拍盏频传。人生何处似尊前。\n第五辑  姜白石词曲扬州慢 淮左名都淳熙丙申至日，予过维扬。夜雪初霁，荠麦弥望。入其城，则四顾萧条，寒水自碧，暮色渐起，戍角悲吟。予怀怆然，感慨今昔，因自度此曲。千岩老人以为有“黍离”之悲也。\n淮左名都，竹西佳处，解鞍少驻初程。过春风十里，尽荠麦青青。自胡马窥江去后，废池乔木，犹厌言兵。渐黄昏，清角吹寒，都在空城。 \n杜郎俊赏，算而今、重到须惊。纵豆蔻词工，青楼梦好，难赋深情。二十四桥仍在，波心荡、冷月无声。念桥边红药，年年知为谁生？\n点绛唇  丁未冬过吴松作燕雁无心，太湖西畔随云去。数峰清苦。商略黄昏雨。\n第四桥边，拟共天随住。今何许。凭阑怀古。残柳参差舞。\n暗香  旧时月色辛亥之冬，余载雪诣石湖。止既月，授简索句，且征新声，作此两曲，石湖把玩不已，使二妓肆习之，音节谐婉，乃名之曰《暗香》、《疏影》。\n旧时月色，算几番照我，梅边吹笛？唤起玉人，不管清寒与攀摘。何逊而今渐老，都忘却春风词笔。但怪得竹外疏花，香冷入瑶席。\n江国，正寂寂，叹寄与路遥，夜雪初积。翠尊易泣，红萼无言耿相忆。长记曾携手处，千树压、西湖寒碧。又片片、吹尽也，几时见得？\n鹧鸪天  元夕有所梦  肥水东流无尽期。当初不合种相思。梦中未比丹青见，暗里忽惊山鸟啼。\n春未绿，鬓先丝。人间别久不成悲。谁教岁岁红莲夜，两处沉吟各自知。\n疏影  苔枝缀玉辛亥之冬，余载雪诣石湖。止既月，授简索句，且征新声，作此两曲，石湖把玩不已，使二妓肆习之，音节谐婉，乃名之曰《暗香》、《疏影》。\n苔枝缀玉，有翠禽小小，枝上同宿。客里相逢，篱角黄昏，无言自倚修竹。昭君不惯胡沙远，但暗忆、江南江北。想佩环、月夜归来，化作此花幽独。\n犹记深宫旧事，那人正睡里，飞近蛾绿。莫似春风，不管盈盈，早与安排金屋。还教一片随波去，又却怨、玉龙哀曲。等恁时、重觅幽香，已入小窗横幅\n鹧鸪天  正月十一日观灯巷陌风光纵赏时。笼纱未出马先嘶。白头居士无呵殿，只有乘肩小女随。 \n花满市，月侵衣。少年情事老来悲。沙河塘上春寒浅，看了游人缓缓归\n齐天乐  蟋蟀丙辰岁，与张功父会饮张达可之堂。闻屋壁间蟋蟀有声，功父约予同赋，以授歌者。功父先成，辞甚美。予裴回末利花间，仰见秋月，顿起幽思，寻亦得此。蟋蟀，中都呼为促织，善斗。好事者或以三二十万钱致一枚，镂象齿为楼观以贮之。\n庾郎先自吟愁赋，凄凄更闻私语。露湿铜铺，苔侵石井，都是曾听伊处。哀音似诉。正思妇无眠，起寻机杼。曲曲屏山，夜凉独自甚情绪？\n西窗又吹暗雨。为谁频断续，相和砧杵？候馆迎秋，离宫吊月，别有伤心无数。豳诗漫与。笑篱落呼灯，世间儿女。写入琴丝，一声声更苦。\n长亭怨慢  渐吹尽余颇喜自制曲。初率意为长短句，然后协以律，故前后阕多不同。桓大司马云：“昔年种柳，依依汉南。今看摇落，凄怆江潭：树犹如此，人何以堪？”此语余深爱之。\n渐吹尽，枝头香絮，是处人家，绿深门户。远浦萦回，暮帆零乱向何许？阅人多矣，谁得似长亭树？树若有情时，不会得青青如此！\n日暮，望高城不见，只见乱山无数。韦郎去也，怎忘得、玉环分付：第一是早早归来，怕红萼无人为主。算空有并刀，难剪离愁千缕。\n淡黄柳  空城晓角客居合肥南城赤阑桥之西，巷陌凄凉，与江左异。唯柳色夹道，依依可怜。因度此阕，以纾客怀。\n空城晓角，吹入垂杨陌。马上单衣寒恻恻。看尽鹅黄嫩绿，都是江南旧相识。\n正岑寂，明朝又寒食。强携酒、小桥宅。怕梨花落尽成秋色。燕燕飞来，问春何在？唯有池塘自碧。\n江梅引  人间离别易多时丙辰之冬，予留梁溪，将诣淮南不得，因梦思以述志。\n人间离别易多时。见梅枝，忽相思。几度小窗幽梦手同携。今夜梦中无觅处，漫徘徊，寒侵被，尚未知。\n湿红恨墨浅封题。宝筝空，无雁飞。俊游巷陌，算空有、古木斜晖。旧约扁舟，心事已成非。歌罢淮南春草赋，又萋萋。漂零客，泪满衣。\n第六辑  淮海集淮海集系秦观所作，秦观，北宋时人，字太虚、海若。江苏高邮人。\n鹊桥仙 纤云弄巧纤云弄巧，飞星传恨，银汉迢迢暗度。金风玉露一相逢，便胜却人间无数。\n柔情似水，佳期如梦，忍顾鹊桥归路。两情若是久长时，又岂在朝朝暮暮。\n浣溪沙  漠漠轻寒上小楼漠漠轻寒上小楼。晓阴无赖似穷秋。淡烟流水画屏幽。\n自在飞花轻似梦，无边丝雨细如愁。宝帘闲挂小银钩。\n满庭芳  山抹微云山抹微云，天连衰草，画角声断谯门。暂停征棹，聊共引离尊。多少蓬莱旧事，空回首、烟霭纷纷。斜阳外，寒鸦万点，流水绕孤村。 \n销魂。当此际，香囊暗解，罗带轻分。谩赢得、青楼薄幸名存。此去何时见也，襟袖上、空惹啼痕。伤情处，高城望断，灯火已黄昏。\n踏莎行  雾失楼台雾失楼台，月迷津渡，桃源望断无寻处。可堪孤馆闭春寒，杜鹃声里斜阳暮。\n驿寄梅花，鱼传尺素，砌成此恨无重数。郴江幸自绕郴山，为谁流下潇湘去？\n江城子  西城杨柳弄春柔西城杨柳弄春柔。动离忧。泪难收。犹记多情，曾为系归舟。碧野朱桥当日事，人不见，水空流。\n韶华不为少年留。恨悠悠。几时休。飞絮落花时候、一登楼。便做春江都是泪，流不尽，许多愁。\n行香子  树绕村庄树绕村庄，水满陂塘。倚东风、豪兴徜徉。小园几许，收尽春光。有桃花红，李花白，菜花黄。\n远远围墙，隐隐茅堂。飏青旗、流水桥旁。偶然乘兴、步过东冈。正莺儿啼，燕儿舞，蝶儿忙\n八六子  倚危亭倚危亭。恨如芳草，萋萋刬尽还生。念柳外青骢别后，水边红袂分时，怆然暗惊。\n无端天与娉婷。夜月一帘幽梦，春风十里柔情。\n怎奈向、欢娱渐随流水，素弦声断，翠绡香减，那堪片片飞花弄晚，蒙蒙残雨笼晴。正销凝。黄鹂又啼数声\n望海潮  梅英疏淡梅英疏淡，冰澌溶泄，东风暗换年华。金谷俊游，铜驼巷陌，新晴细履平沙。长记误随车。正絮翻蝶舞，芳思交加。柳下桃蹊，乱分春色到人家。\n西园夜饮鸣笳。有华灯碍月，飞盖妨花。兰苑未空，行人渐老，重来是事堪嗟。烟暝酒旗斜。但倚楼极目，时见栖鸦。无奈归心，暗随流水到天涯。\n南乡子  妙手写徽真妙手写徽真，水剪双眸点绛唇。疑是昔年窥宋玉，东邻，只露墙头一半身。\n往事已酸辛，谁记当年翠黛颦？尽道有些堪恨处，无情，任是无情也动人。\n临江仙  千里潇湘挼蓝浦千里潇湘挼蓝浦，兰桡昔日曾经。月高风定露华清。微波澄不动，冷浸一天星。\n独倚危樯情悄悄，遥闻妃瑟泠泠。新声含尽古今情。曲终人不见，江上数峰青。\n江城子  南来飞燕北归鸿南来飞燕北归鸿，偶相逢，惨愁容。绿鬓朱颜重见两衰翁。别后悠悠君莫问，无限事，不言中。\n小槽春酒滴珠红，莫匆匆，满金钟。饮散落花流水各西东。后会不知何处是？烟浪远，暮云重。\n阮郎归  春风吹雨绕残枝春风吹雨绕残枝，落花无可飞。小池寒绿欲生漪，雨晴还日西。\n帘半卷，燕双归，讳愁无奈眉。翻身整顿着残棋，沉吟应劫迟。\n鹧鸪天  枝上流莺和泪闻枝上流莺和泪闻，新啼痕间旧啼痕。一春鱼鸟无消息，千里关山劳梦魂。\n无一语，对芳尊。安排肠断到黄昏。甫能炙得灯儿了，雨打梨花深闭门。\n第七辑  温飞卿诗集商山早行晨起动征铎，客行悲故乡。鸡声茅店月，人迹板桥霜。槲叶落山路，枳花明驿墙。因思杜陵梦，凫雁满回塘。\n望江南 梳洗罢梳洗罢，独倚望江楼。过尽千帆皆不是，斜晖脉脉水悠悠。肠断白蘋洲。\n菩萨蛮 小山重叠金明灭小山重叠金明灭，鬓云欲度香腮雪。懒起画蛾眉，弄妆梳洗迟。照花前后镜，花面交相映。新帖绣罗襦，双双金鹧鸪。\n梦江南 千万恨千万恨，恨极在天涯。山月不知心里事，水风空落眼前花，摇曳碧云斜\n第八辑  浣花词浣花词为韦庄所作词，韦庄，字端已。五代蜀人。\n菩萨蛮 人人尽说江南好人人尽说江南好，游人只合江南老。春水碧于天，画船听雨眠。垆边人似月，皓腕凝霜雪。未老莫还乡，还乡须断肠。\n思帝乡 春日游春日游，杏花吹满头。陌上谁家年少足风流？\n妾拟将身嫁与一生休。纵被无情弃，不能羞。\n菩萨蛮 劝君今夜须沉醉劝君今夜须沉醉，尊前莫话明朝事。珍重主人心，酒深情亦深。须愁春漏短，莫诉金杯满。遇酒且呵呵，人生能几何。\n女冠子 四月十七四月十七，正是去年今日，别君时。忍泪佯低面，含羞半敛眉。不知魂已断，空有梦相随。除却天边月，没人知。\n谒金门 春雨足春雨足，染就一溪新绿。柳外飞来双羽玉，弄晴相对浴。楼外翠帘高轴，倚遍阑干几曲。云淡水平烟树簇，寸心千里目。\n第九辑  竹山词竹山词为蒋捷所作，蒋捷，南宋时人。\n虞美人  听雨[宋] 蒋捷\n少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低，断雁叫西风。\n而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前，点滴到天明。\n一剪梅  舟过吴江[宋] 蒋捷\n一片春愁待酒浇。江上舟摇，楼上帘招。秋娘渡与泰娘桥，风又飘飘，雨又萧萧。\n何日归家洗客袍？银字笙调，心字香烧。流光容易把人抛，红了樱桃，绿了芭蕉。\n声声慢 秋声黄花深巷，红叶低窗，凄凉一片秋声。豆雨声来，中间夹带风声。疏疏二十五点，丽谯门、不锁更声。故人远，问谁摇玉佩，檐底铃声？\n彩角声吹月堕，渐连营马动，四起笳声。闪烁邻灯，灯前尚有砧声。知他诉愁到晓，碎哝哝、多少蛩声！诉未了，把一半、分与雁声。\n贺新郎 兵后寓吴深阁帘垂绣，记家人、软语灯边，笑涡红透。万叠城头哀怨角，吹落霜花满袖。影厮伴、东奔西走。望断乡关知何处?羡寒鸦、到著黄昏后。一点点，归杨柳。\n相看只有山如旧。叹浮云、本是无心，也成苍狗。明日枯荷包冷饭，又过前头小阜。趁未发、且尝村酒。醉探枵囊毛锥在，问邻翁、要写牛经否?翁不应，但摇手。\n第十辑  刘辰翁词笔柳梢青·春感铁马蒙毡，银花洒泪，春入愁城。笛里番腔，街头戏鼓，不是歌声。那堪独坐青灯。想故国、高台月明。辇下风光，山中岁月，海上心情。\n山花子·此处情怀欲问天此处情怀欲问天，相期相就复何年。行过章江三十里，泪依然。早宿半程芳草路，犹寒欲雨暮春天。小小桃花三两处，得人怜。\n唐多令·明月满沧洲明月满沧洲。长江一意流。更何人、横笛危楼。天地不知兴废事，三十万、八千秋。\n落叶女墙头。铜驼无恙不。看青山、白骨堆愁。除却月宫花树下，尘坱莽、欲何游。\n第十一辑  山谷词山谷词为江西诗派开山之祖黄庭坚所作，黄庭坚，字鲁直，号山谷道人。文学家，书法家。\n清平乐·春归何处春归何处。寂寞无行路。若有人知春去处。唤取归来同住。\n 春无踪迹谁知。除非问取黄鹂。百啭无人能解，因风飞过蔷薇\n虞美人·宜州见梅作天涯也有江南信。梅破知春近。夜阑风细得香迟。不道晓来开遍、向南枝。 \n玉台弄粉花应妒。飘到眉心住。平生个里愿杯深。去国十年老尽、少年心。\n鹧鸪天·座中有眉山隐客史应之和前韵即席答之黄菊枝头生晓寒。人生莫放酒杯干。风前横笛斜吹雨，醉里簪花倒著冠。 \n身健在，且加餐。舞裙歌板尽清欢。黄花白发相牵挽，付与时人冷眼看\n菩萨蛮·半烟半雨溪桥畔半烟半雨溪桥畔，渔翁醉着无人唤。疏懒意何长，春风花草香。\n江山如有待，此意陶潜解。问我去何之，君行到自知。\n赠衡阳妓陈湘鸳鸯翡翠，小小思珍偶。眉黛敛秋波，尽湖南、山明水秀。娉娉袅袅，恰近十三余。春未透，花枝瘦，正是愁时候。\n寻花载酒，肯落谁人后？只恐远归来，绿成阴、青梅如豆。心期得处，每自不由人，长亭柳，君知否，千里犹回首。\n第十二辑  稼轩长短句辛弃疾，字幼安，号稼轩，善为词，可谓篇篇佳作，余读其词，拊手频频。选之一二示下。\n鹧鸪天·代人赋晚日寒鸦一片愁。柳塘新绿却温柔。若教眼底无离恨，不信人间有白头。\n肠已断，泪难收。相思重上小红楼。情知已被山遮断，频倚阑干不自由。\n鹧鸪天·陌上柔桑破嫩芽陌上柔桑破嫩芽，东邻蚕种已生些。平冈细草鸣黄犊，斜日寒林点暮鸦。\n山远近，路横斜，青旗沽酒有人家。城中桃李愁风雨，春在溪头荠菜花。\n水调歌头·壬子三山被召陈端仁给事饮饯席上作长恨复长恨，裁作短歌行。何人为我楚舞，听我楚狂声？余既滋兰九畹，又树蕙之百亩，秋菊更餐英。门外沧浪水，可以濯吾缨。一杯酒，问何似，身后名？人间万事，毫发常重泰山轻。悲莫悲生离别，乐莫乐新相识，儿女古今情。富贵非吾事，归与白鸥盟。\n第十三辑 东坡词放眼北宋文坛，惟东坡一人而已。其造诣所及之处，可谓全矣。\n浣溪沙·细雨斜风作晓寒元丰七年十二月二十四日，从泗州刘倩叔游南山\n细雨斜风作晓寒，淡烟疏柳媚晴滩。入淮清洛渐漫漫。雪沫乳花浮午盏，蓼茸蒿笋试春盘。人间有味是清欢。\n西江月·顷在黄州顷在黄州，春夜行蕲水中，过酒家饮，酒醉，乘月至一溪桥上，解鞍，由肱醉卧少休。及觉已晓，乱山攒拥，流水锵然，疑非尘世也。书此语桥柱上。\n照野弥弥浅浪，横空隐隐层霄。障泥未解玉骢骄，我欲醉眠芳草。可惜一溪风月，莫教踏碎琼瑶。解鞍欹枕绿杨桥，杜宇一声春晓。\n蝶恋花·暮春别李公择簌簌无风花自堕。寂寞园林，柳老樱桃过。落日有情还照坐，山青一点横云破。路尽河回人转舵。系缆渔村，月暗孤灯火。凭仗飞魂招楚些，我思君处君思我。\n临江仙·夜饮东坡醒复醉夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。\n临江仙·送钱穆父一别都门三改火，天涯踏尽红尘。依然一笑作春温。无波真古井，有节是秋筠。惆怅孤帆连夜发，送行淡月微云。尊前不用翠眉颦。人生如逆旅，我亦是行人。\n定风波·南海归赠王定国侍人寓娘常羡人间琢玉郎，天应乞与点酥娘。尽道清歌传皓齿，风起，雪飞炎海变清凉。\n万里归来颜愈少，微笑，笑时犹带岭梅香。试问岭南应不好，却道：此心安处是吾乡。\n南乡子·和杨元素时移守密州东武望余杭，云海天涯两渺茫。何日功成名遂了，还乡，醉笑陪公三万场。不用诉离觞，痛饮从来别有肠。今夜送归灯火冷，河塘，堕泪羊公却姓杨。\n第十四辑  元曲摘选折桂令·春情元代：徐再思\n平生不会相思，才会相思，便害相思。身似浮云，心如飞絮，气若游丝。空一缕余香在此，盼千金游子何之。证候来时，正是何时？灯半昏时，月半明时。\n人月圆·山中书事元代：张可久\n兴亡千古繁华梦，诗眼倦天涯。孔林乔木，吴宫蔓草，楚庙寒鸦。数间茅舍，藏书万卷，投老村家。山中何事？松花酿酒，春水煎茶。\n","categories":["诗歌手记"]},{"title":"自定义注解实现AOP切面","url":"/2023/10/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0AOP%E5%88%87%E9%9D%A2/","content":"\n\n面向切面编程，Spring AOP核心概念、使用示例。\n\n\n1、基础概念1.1、切面(Aspect)首先要理解‘切’字，需要把对象想象成一个立方体，传统的面向对象思维，类定义完成之后（封装）。每次实例化一个对象，对类定义中的成员变量赋值，就相当于对这个立方体进行了一个定义，定义完成之后，那个对象就在那里，不卑不亢，不悲不喜，等着被使用，等着被回收。\n面向切面编程则是指，对于一个我们已经封装好的类，我们可以在编译期间或在运行期间，对其进行切割，把立方体切开，在原有的方法里面添加（织入）一些新的代码，对原有的方法代码进行一次增强处理。而那些增强部分的代码，就被称之为切面，如下面代码实例中的通用日志处理代码，常见的还有事务处理、权限认证等等。\n2、切入点(PointCut)要对哪些类中的哪些方法进行增强，进行切割，指的是被增强的方法。即要切哪些东西。\n3、连接点(JoinPoint)我们知道了要切哪些方法后，剩下的就是什么时候切，在原方法的哪一个执行阶段加入增加代码，这个就是连接点。如方法调用前，方法调用后，发生异常时等等。\n4、通知(Advice)通知被织入方法，该如何被增强。定义切面的具体实现。那么这里面就涉及到一个问题，空间（切哪里）和时间（什么时候切，在何时加入增加代码），空间我们已经知道了就是切入点中定义的方法，而什么时候切，则是连接点的概念，如下面实例中，通用日志处理（切面），@Pointcut规则中指明的方法即为切入点，@Before、@After是连接点，而下面的代码就是对应通知。\n@Before(&quot;cutMethod()&quot;)public void begin() &#123;    System.out.println(&quot;==@Before== lingyejun blog logger : begin&quot;);&#125;\n\n5、目标对象(Target Object)被一个或多个切面所通知的对象，即为目标对象。\n6、AOP代理对象(AOP Proxy Object)AOP代理是AOP框架所生成的对象，该对象是目标对象的代理对象。代理对象能够在目标对象的基础上，在相应的连接点上调用通知。\n7、织入(Weaving)将切面切入到目标方法之中，使目标方法得到增强的过程被称之为织入。\n2、示例插曲：IDEA右键新建时，选项竟然没有Java Class\n背景：利用aop实现日志切面。\n步骤：\n1、导入切面需要的依赖&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n2、自定义注解 AOPLogTarget：描述了注解修饰的对象范围，有如下取值：\n\nMETHOD：用于描述方法\nPACKAGE：用于描述包\nPARAMETER：用于描述方法变量\nTYPE：用于描述类、接口或enum类型\n\nRetention：表示注解保留时间长短\n\nSOURCE：在源文件中有效，编译过程中会被忽略\nCLASS：随源文件一起编译在class文件中，运行时忽略\nRUNTIME：在运行时有效\n\n只有定义为 RetentionPolicy.RUNTIME（在运行时有效）时，我们才能通过反射获取到注解，然后根据注解的一系列值，变更不同的操作。\n// 指定注解使用在方法上@Target(ElementType.METHOD)// 指定生效至运行时@Retention(RetentionPolicy.RUNTIME)public @interface AOPLog &#123;    /**     * 指定是否详情显示     * true 显示详情, 默认false     *     * @return     */    boolean isDetail() default false;&#125;\n\n3、定义切面类补充：切入点表达式\n1）bean表达式\nbean表达式一般应用于类级别，实现粗粒度的切入点定义，案例分析：\nbean(“userServiceImpl”)  指定一个userServiceImpl类中所有方法。\nbean(“*ServiceImpl”)  指定所有后缀为ServiceImpl的类中所有方法。\n2）within表达式\nwithin表达式应用于类级别，实现粗粒度的切入点表达式定义，案例分析：\n\nwithin(“aop.service.UserServiceImpl”)  指定当前包中这个类内部的所有方法。\nwithin(“aop.service.*”)  指定当前目录下的所有类的所有方法。\nwithin(“aop.service…*”)  指定当前目录以及子目录中类的所有方法。\n\n3）execution表达式\nexecution表达式应用于方法级别，实现细粒度的切入点表达式定义，案例分析：语法：execution(返回值类型 包名.类名.方法名(参数列表))。\n\nexecution(void aop.service.UserServiceImpl.addUser())  匹配addUser方法。\nexecution(void aop.service.PersonServiceImpl.addUser(String))  方法参数必须为String的addUser方法。\nexecution(* aop.service…*.*(…))  万能配置。\n\n4）@annotation表达式\n@annotaion表达式应用于方法级别，实现细粒度的切入点表达式定义，案例分析\n\n@annotation(anno.RequiredLog) 匹配有此注解描述的方法。\n@annotation(anno.RequiredCache) 匹配有此注解描述的方法。\n\n@Aspect@Componentpublic class AOPLogAspect &#123;    private static Logger log = LoggerFactory.getLogger(AOPLogAspect.class);    /**     * 指定切点, 切点的位置是存在该注解com.example.aoptest.AOPLog     */    @Pointcut(&quot;@annotation(com.example.aoptest.AOPLog)&quot;)    public void logPointCut() &#123;    &#125;    /**     * 环绕通知, 该处写具体日志逻辑     *     * @param joinPoint     */    @Around(&quot;logPointCut()&quot;)    public void logAround(ProceedingJoinPoint joinPoint) &#123;        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        // 获取方法名称        String methodName = signature.getName();        // 获取入参        Object[] param = joinPoint.getArgs();        StringBuilder sb = new StringBuilder();        for (Object o : param) &#123;            sb.append(o).append(&quot;; &quot;);        &#125;        log.info(&quot;进入方法[&#123;&#125;], 参数有[&#123;&#125;]&quot;, methodName, sb.toString());        String resp = &quot;&quot;;        try &#123;            Object proceed = joinPoint.proceed();            resp = JSON.toJSONString(proceed, SerializerFeature.WriteMapNullValue);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();        &#125;        // 获取方法上的注解，判断如果isDetail值为true，则打印结束日志        Method method = signature.getMethod();        AOPLog annotation = method.getAnnotation(AOPLog.class);        boolean isDetail = annotation.isDetail();        if (isDetail) &#123;            log.info(&quot;方法[&#123;&#125;]执行结束, 返回值[&#123;&#125;]&quot;, methodName, resp);        &#125;    &#125;&#125;\n\n4. 编写测试接口@RestControllerpublic class AopLogController &#123;    // 指定注解@AOPLog    @AOPLog    @GetMapping(&quot;/testAOP&quot;)    public String testAOPLog() &#123;        return &quot;ok&quot;;    &#125;    // 指定注解@AOPLog, 同时isDetail = true    @AOPLog(isDetail = true)    @GetMapping(&quot;/testAOPLogDetail&quot;)    public String testAOPLogDetail() &#123;        return &quot;ok&quot;;    &#125;&#125;","categories":["Spring Boot"]},{"title":"Gateway+JWT实现登录认证","url":"/2023/10/04/Gateway+JWT%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/","content":"\n\n微服务架构整合Spring Cloud Gateway网关和JWT Token实现登录认证。\n\n\n1、认证、授权、凭证1.1 认证（Authentication）认证表示你是谁。系统如何正确分辨出操作用户的真实身份，比如通过输入用户名和密码来辨别身份。\n1.2 授权（Authorization）授权表示你能干什么。系统如何控制一个用户能看到哪些数据和操作哪些功能，也就是具有哪些权限。\n1.3 凭证（Credential）表示你如何证明你的身份。系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整和不可抵赖的。\n关于凭证的存储方案，业界的安全架构中有两种方案：\n\nCookie-Session 模式\nJWT 方案\n\n1.3.1、Cookie-Session 模式如下图示：\n\n优点：\n状态信息都存储于服务器，只要依靠客户端的同源策略和 HTTPS 的传输层安全，保证 Cookie 中的键值不被窃取而出现被冒认身份的情况，就能完全规避掉上下文信息在传输过程中被泄漏和篡改的风险。\n缺点：\n在单节点的单体服务中再适合不过，但是如果需要水平扩展要部署集群就很麻烦。\n如果让 session 分配到不同的的节点上，不重复地保存着一部分用户的状态，用户的请求固定分配到对应的节点上，如果某个节点崩溃了，则里面的用户状态就会完全丢失。如果让 session 复制到所有节点上，那么同步的成本又会很高。\n1.3.2、JWT方案上面说到 Cookie-Session 机制在分布式环境下会遇到一致性和同步成本的问题，而且如果在多方系统中，则更不能将 Session 共享存放在多方系统的服务端中，即使服务端之间能共享数据，Cookie 也没有办法跨域。\n转换思路，服务端不保存任何状态信息，由客户端来存储，每次发送请求时携带这个状态信息发给后端服务。原理图如下所示：\n\nJWT（JSON WEB TOKEN）是一种令牌格式，经常与 OAuth2.0 配合应用于分布式、多方的应用系统中。\n我们先来看下 JWT 的格式长什么样：\n\n左边的字符串就是 JWT 令牌，JWT 令牌是服务端生成的，客户端会拿着这个 JWT 令牌在每次发送请求时放到 HTTP header 中。\n而右边是 JWT 经过 Base64 解码后展示的明文内容，而这段明文内容的最下方，又有一个签名内容，可以防止内容篡改，但是不能解决泄漏的问题。\nJWT 格式\nJWT 令牌是以 JSON 结构存储，用点号分割为三个部分。\n\n第一部分是令牌头（Header），内容如下所示：\n&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;\n\n它描述了令牌的类型（统一为 typ:JWT）以及令牌签名的算法，示例中 HS256 为 HMAC SHA256 算法的缩写。\n令牌的第二部分是负载（Payload），这是令牌是真正需要向服务端传递的信息。但是服务端不会直接用这个负载，而是通过加密传过来的 Header 和 Payload 后再比对签名是否一致来判断负载是否被篡改，如果没有被篡改，才能用 Payload 中的内容。因为负载只是做了 base64 编码，并不是加密，所以是不安全的，千万别把敏感信息比如密码放到负载里面。\n&#123;  &quot;sub&quot;: &quot;passjava&quot;,  &quot;name&quot;: &quot;悟空聊架构&quot;,  &quot;iat&quot;: 1516239022&#125;\n\n\n\n令牌的第三部分是签名（Signature），使用在对象头中公开的特定签名算法，通过特定的密钥（Secret，由服务器进行保密，不能公开）对前面两部分内容进行加密计算，以例子里使用的 JWT 默认的 HMAC SHA256 算法为例，将通过以下公式产生签名值：\nHMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload) , secret)\n\n签名的意义：确保负载中的信息是可信的、没有被篡改的，也没有在传输过程中丢失任何信息。因为被签名的内容哪怕发生了一个字节的变动，也会导致整个签名发生显著变化。此外，由于签名这件事情只能由认证授权服务器完成（只有它知道 Secret），任何人都无法在篡改后重新计算出合法的签名值，所以服务端才能够完全信任客户端传上来的 JWT 中的负载信息。\nJWT 的优势\n\n无状态：不需要服务端保存 JWT 令牌，也就是说不需要服务节点保留任何一点状态信息，就能在后续的请求中完成认证功能。\n天然的扩容便利：服务做水平扩容不用考虑 JWT 令牌，而 Cookie-Session 是需要考虑扩容后服务节点如何存储 Session 的。\n不依赖 Cookie：JWT 可以存放在浏览器的 LocalStorage，不一定非要存储在 Cookie 中。\n\nJWT 的劣势\n\n令牌难以主动失效：JWT 令牌签发后，理论上和认证的服务器就没有什么关系了，到期之前始终有效。除非服务器加些特殊的逻辑处理来缓存 JWT，并来管理 JWT 的生命周期，但是这种方式又会退化成有状态服务。而这种要求有状态的需求又很常见：譬如用户退出后，需要重新输入用户名和密码才能登录；或者用户只允许在一台设备登录，登录到另外一台设备，要求强行退出。但是这种有状态的模式，降低了 JWT 本身的价值。\n更容易遭受重放攻击：Cookie-Session 也有重放攻击的问题，也就是客户端可以拿着这个 cookie 不断发送大量请求，对系统性能造成影响。但是因为 Session 在服务端也有一份，服务端可以控制 session 的生命周期，应对重放攻击更加主动一些。但是 JWT 的重放攻击对于服务端来说就很被动，比如通过客户端的验证码、服务端限流或者缩短令牌有效期，应用起来都会麻烦些。\n存在泄漏的风险：客户端存储，很有可能泄漏出去，被其他人重复利用。\n信息大小有限：HTTP 协议并没有强制约束 Header 的最大长度，但是服务器、浏览器会做限制。而且如果令牌很大还会消耗传输带宽。\n\n2、认证原理图在如下的认证时序图中，有以下几种角色：\n\n客户端：表示 APP 端或 PC 端的前端页面。\n网关：表示 Spring Cloud Gateway 网关服务。\n认证服务：用来接收客户的登录请求、登出请求、刷新令牌的操作。\n业务服务：和系统业务相关的微服务。\n\n认证和校验身份的流程如下所示：\n\n① 用户登录：客户端在登录页面输入用户名和密码，提交表单，调用登录接口。\n② 转发请求：这里会先将登录请求发送到网关服务 passjava-gateway，网关对于登录请求会直接转发到认证服务 passjava-auth。（网关对登录请求不做 token 校验，这个可以配置不校验哪些请求 URL）\n③ 认证：认证服务会将请求参数中的用户名+密码和数据库中的用户进行比对，如果完全匹配，则认证通过。\n④ 生成令牌：生成两个令牌：access_token 和 refresh_token（刷新令牌），刷新令牌我们后面再说，这里其实也可以只用生成一个令牌 access_token。令牌里面会包含用户的身份信息，如果要做权限管控，还需要在 token 里面包含用户的权限信息，权限这一块不在本篇展开，会放到下一篇中进行讲解。\n⑤ 客户端缓存 token：客户端拿到两个 token 缓存到 cookie 中或者 LocalStorage 中。\n⑥ 携带 token 发起请求：客户端下次想调用业务服务时，将 access_token 放到请求的 header 中。\n⑦ 网关校验 token：请求还是先到到网关服务，然后由它校验 access_token 是否合法。如果 access_token 未过期，且能正确解析出来，就说明是合法的 access_token。\n⑧ 携带用户身份信息转发请求：网关将 access_token 中携带的用户的 user_id 放到请求的 header 中，转发给真正的业务服务。\n⑨ 处理业务逻辑：业务服务从 header 中拿到用户的 user_id，然后处理业务逻辑，处理完后将结果延原理返回给客户端。\n3、实现细节更多细节见：实战SpringCloud gateway+JWT认证\n3.1、如何做登录认证 \n步骤：\n\n提交用户名和密码\n网关服务转发登录请求\n数据库查找用户密码，验证成功后生成JWT令牌\n\n3.2、如何生成令牌生成令牌就是通过工具类 PassJavaJwtTokenUtil 生成 JWT Token。\n3.3、如何携带JWT发送请求\n客户端（浏览器或 APP）拿到 JWT 后，可以将 JWT 存放在浏览器的 Cookie 或 LocalStorage（本地存储） 或者内存中。\n发送请求时在请求 Header 的 Authorization 字段中设置 JWT。\n3.4、网关如何验证和转发请求\n网关接收到前端发起的业务请求后，会先验证请求的 Header 中是否携带 Authorization 字段，以及里面的 Token 是否合法。然后解析 Token 中的 userId 和 username，放到 header 中再进行转发。\n网关是通过多个过滤器 Filter对请求进行串行拦截处理的，所以我们可以自定义一个全局过滤器，对所有请求进行校验，当然对于一些特殊请求比如登录请求就不需要校验了，因为调用登录请求的时候还没有生成 Token。\n\n3.5、会员业务逻辑处理会员服务接收到网关转发的请求后，就从 Header 中拿到用户身份信息，然后通过 userId 获取会员信息。\n获取 userId 的方式其实可以通过加一个拦截器，由拦截器将 Header 中的 userId 和 username 放到线程中，后续的 controller，service，dao 类都可以从线程里面拿到 userId 和 username，不用通过传参的方式。\n获取 userId 的方式：\n\n方式一：从 request 的 Header 中拿到 userId。代码简单，但是如果其他地方也要用到 userId，则需要通过方法传参的方式传递 userId。\n方式二：从线程变量里面拿到 userId。代码复杂，使用简单。好处是所有地方统一从一个地方获取。\n\n3.6、如何刷新令牌当认证服务返回给客户端的 JWT 也就是 access_token 过期后，客户端是通过发送登录请求重新拿到 access_token 吗？\n这种重新登录的操作如果很频繁（因 JWT 过期时间较短），对于用户来说体验就很差了。客户端需要跳转到登录页面，让用户重新提交用户名和密码，即使客户端有记住用户名和密码，但是这种跳转的到登录页的操作会大幅度降低用户的体验。\n有没有一种比较优雅的方式让客户端重新拿到 access_token 或者说延长 access_token 有效期呢？\n我们知道 JWT 生成后是不能篡改里面的内容，即使是 JWT 的有效期也不行。所以延长 access_token 有效期的做法并不适合，而且如果长期保持一个 access_token 有效，也是不安全的。\n那就只能重新生成 access_token 了。方案其实挺简单，客户端拿之前生成的 JWT 调用后端一个接口，然后后端校验这个 JWT 是否合法，如果是合法的就重新生成一个新的返回给客户端。客户端自行替换掉之前本地保存的 access_token 就可以了。\n\n这里有一个巧妙的设计，就是生成 JWT 时，返回了两个 JWT token，一个 access_token，一个 refresh_token，这两个 token 其实都可以用来刷新 token，但是我们把 refresh_token 设置的过期时间稍微长一点，比如两倍于 access_token，当 access_token 过期后，refresh_token 如果还没有过期，就可以利用两者的过期时间差进行重新生成令牌的操作，也就是刷新令牌，这里的刷新指的是客户端重置本地保存的令牌，以后都用新的令牌。\n总结：\n在登录认证中，刷新令牌和设置过期重登是常见的安全机制，用于保证用户的登录状态和防止令牌被滥用。下面是一种常见的实现方式：\n\n生成令牌和刷新令牌：\n- 在用户登录成功后，生成一个访问令牌（access token）和一个刷新令牌（refresh token）。\n- 访问令牌用于验证用户的身份和访问权限，通常具有较短的有效期。\n- 刷新令牌用于在访问令牌过期时获取新的访问令牌，通常具有较长的有效期。\n\n访问令牌的验证：\n- 在每个请求中，服务端需要验证访问令牌的有效性。\n- 可以通过在请求头或请求参数中携带访问令牌，并在服务端进行解析和验证。\n- 如果访问令牌已过期或无效，服务端会返回相应的错误响应。\n\n刷新令牌的使用：\n- 当访问令牌过期时，客户端可以使用刷新令牌来获取新的访问令牌。\n- 客户端发送一个特殊的请求，携带刷新令牌。\n- 服务端验证刷新令牌的有效性，并根据刷新令牌颁发一个新的访问令牌。\n\n设置过期重登：\n- 如果用户长时间不活动或注销登录，访问令牌会过期失效。\n- 当用户再次访问需要登录的接口时，服务端会返回一个需要重新登录的错误响应。\n- 客户端收到该错误响应后，需要引导用户重新进行登录认证。\n\n\n通过刷新令牌和设置过期重登的机制，可以在保证用户登录状态的同时，提高系统的安全性。请注意，具体的实现方式可能会根据实际情况和框架的不同而有所差异。\n","categories":["项目实战"]},{"title":"Spring Cloud Gateway详解","url":"/2023/10/03/Spring-Cloud-Gateway%E8%AF%A6%E8%A7%A3/","content":"\n\n微服务网关，为什么需要API网关？网关的工作流程，断言、动态路由、过滤器、token认证。\n\n\n1、为什么需要API网关？在 SpringCloud 微服务架构中，往往有多个微服务，这些微服务可能部署在不同的机器上，而且一个微服务可能会扩容成多个相同的微服务，组成微服务集群。\n这种情况下，会存在如下问题：\n\n如果需要添加鉴权功能，则需要对每个微服务进行改造。\n如果需要对流量进行控制，则需要对每个微服务进行改造。\n跨域问题，需要对每个微服务进行改造。\n存在安全问题，每个微服务需要暴露自己的 Endpoint 给客户端。\n\nEndpoint 就是服务的访问地址 + 端口，比如下面的地址：\nhttp://order.passjava.cn:8000\n\n灰度发布、动态路由需要对每个微服务进行改造。\n\n这个问题的痛点是各个微服务都是一个入口，有没有办法统一入口呢？\n解决这个问题的方式就是在客户端和服务器之间加个中间商就好了呀，只有中间商一个入口，这个中间商就是网关。\n2、工作流程Gateway 的工作流程如下图所示：\n\n① 路由判断；客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。\n② 请求过滤：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在…之前”。\n③ 服务处理：后端服务会对请求进行处理。\n④ 响应过滤： 后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在…之后”。\n⑤ 响应返回：响应经过过滤处理后，返回给客户端。\n小结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。\n3、断言断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。\n在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。\n断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 api&#x2F;thirdparty，就匹配到了第一个路由 route_thirdparty。\n\n接下来我们看下 Route 路由和 Predicate 断言的对应关系：\n\n\n一对多：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。\n同时满足：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。\n第一个匹配成功：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。\n\n常见的 Predicate 断言配置如下所示，假设匹配路由成功后，转发到 http://localhost:9001。\n\n代码演示：\n下面演示 Gateway 中通过断言来匹配路由的例子。\n\n新建一个 Maven 工程，引入 Gateway 依赖。\n\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n新建 application.yml 文件，添加 Gateway 的路由规则。\n\nspring:  cloud:    gateway:      routes:        - id: route_qq          uri: http://www.qq.com          predicates:            - Query=url,qq        - id: route_baidu          uri: http://www.baidu.com          predicates:            - Query=url,baiduserver:  port: 8060 复制复制失败复制成功\n\n\n\n第一条路由规则：断言为 Query&#x3D;url,qq，表示当请求路径中包含 url&#x3D;qq，则跳转到http://www.qq.com\n第二条路由规则：当请求路径中包含 url&#x3D;baidu，则跳转到http://www.baidu.com\n4、动态路由在微服务架构中，我们不会直接通过 IP + 端口的方式访问微服务，而是通过服务名的方式来访问。如下图所示，微服务中加入了注册中心，多个微服务将自己注册到了注册中心，这样注册中心就保存了服务名和 IP+端口的映射关系。\n\n网关经过断言匹配到一个路由后，将请求转发给指定 uri，这个 uri 可以配置成 微服务的名字，比如 passjava-member。\n那么这个服务名具体要转发到哪个 IP 地址和端口上呢？这个就依赖注册中心的注册表了，Gateway 从注册中心拉取注册表，就能知道服务名对应具体的 IP + 端口，如果一个服务部署了多台机器，则还可以通过负载均衡进行请求的转发。\n对应的配置为 uri 字段如下所示\nuri: lb:&#x2F;&#x2F;passjava-question，表示将请求转发给 passjava-question 微服务，且支持负载均衡。lb 是 loadbalance（负载均衡) 单词的缩写。\n那什么叫动态路由呢？\n当 passjava-question 服务添加一个微服务，或者 IP 地址更换了，Gateway 都是可以感知到的，但是配置是不需要更新的。这里的动态指的是微服务的集群个数、IP 和端口是动态可变的。\n5、过滤器过滤器 Filter 按照请求和响应可以分为两种：Pre 类型和 Post 类型。\nPre 类型：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。\nPost 类型：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。\n另外一种分类是按照过滤器 Filter 作用的范围进行划分：\nGlobalFilter：全局过滤器，应用在所有路由上的过滤器。\nGatewayFilter：局部过滤器，应用在单个路由或一组路由上的过滤器。\n6、token认证在用 Gateway 做登录认证的时候，通常需要我们自定义一个全局过滤器做登录认证。\n比如客户端登录时，将用户名和密码发送给网关，网关转发给认证服务器后，如果账号密码正确，则拿到一个 JWT token，然后客户端再访问应用服务时，先将请求发送给网关，网关统一做 JWT 认证，如果 JWT 符合条件，再将请求转发给应用服务。\n原理如下图所示：\n\n","categories":["Spring Cloud"]}]